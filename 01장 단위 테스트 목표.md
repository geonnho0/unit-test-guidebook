## 1.1 단위 테스트 현황

단위 테스트는 오늘날 소프트웨어 개발의 필수적인 과정으로 여겨집니다. 하지만 많은 개발팀이 단위 테스트를 작성하고 관리하는 데 어려움을 느끼며, 그 실효성에 대해 의문을 제기하기도 합니다. 이상적인 단위 테스트는 코드 변경에 대한 확신을 심어주고, 버그를 개발 초기에 발견하게 하며, 더 나은 코드 설계를 유도하는 역할을 해야 합니다. 하지만 실제 현장에서는 테스트 작성이 또 다른 짐이 되거나, 실제 버그는 잡지 못하면서 코드 리팩터링 과정에서만 실패하는 깨지기 쉬운 테스트가 되어버리는 경우가 많습니다.

이러한 문제가 발생하는 근본적인 원인은 단위 테스트의 진정한 ‘목표’에 대한 이해가 부족하기 때문입니다. 많은 개발자들이 단순히 코드 커버리지를 높이는 것을 목표로 삼거나, 모든 클래스를 독립적으로 테스트해야 한다는 생각에 얽매여 있습니다. 그러나 이런 접근 방식은 오히려 유지보수 비용만 증가시키고 테스트 스위트 전체의 가치를 떨어뜨릴 수 있습니다.

이 책은 이러한 현황을 정확히 파악하고, 단위 테스트의 진정한 목표가 무엇인지 명확히 정의하는 것에서부터 시작합니다. 특히 스프링 백엔드 개발자가 실무에서 흔히 겪는 문제들을 중심으로, 가치 있는 단위 테스트를 작성하고 유지하기 위한 실용적인 지식과 패턴을 깊이 있게 다룰 것입니다. 이 책을 통해 독자들은 단위 테스트에 대한 기존의 잘못된 생각에서 벗어나, 개발 속도를 향상시키고 코드 품질을 높이는 강력한 도구로서 단위 테스트를 활용하는 방법을 배우게 될 것입니다.

## 1.2 단위 테스트 목표

단위 테스트의 가장 중요한 목표는 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것입니다. 여기서 핵심은 '지속 가능성'입니다. 테스트가 없는 프로젝트는 초기에 빠르게 개발되는 것처럼 보일 수 있습니다. 하지만 시간이 지나면서 코드베이스는 점점 복잡해지고, 작은 변경만으로도 예상치 못한 곳에서 버그가 발생하는 일이 잦아집니다. 결국 개발 속도는 현저히 느려지고, 기능 하나를 추가하거나 수정하는 데 엄청난 시간과 노력이 들어가게 됩니다.

좋은 테스트 스위트는 이런 문제에 대한 안전망 역할을 합니다. 코드를 수정하거나 리팩터링한 후에 기존 기능이 여전히 올바르게 동작하는지 신속하게 검증할 수 있게 해줍니다. 이는 개발자가 자신감을 갖고 코드를 변경할 수 있도록 만들며, 결과적으로 장기적인 개발 속도를 유지하고 생산성을 높이는 원동력이 됩니다.

간혹 단위 테스트 작성이 더 나은 설계를 유도한다고 말하기도 합니다. 이는 사실이지만, 부수적인 효과일 뿐 주된 목표는 아닙니다. 테스트하기 어려운 코드는 대개 역할과 책임이 명확하지 않거나 다른 코드와 너무 강하게 결합되어 있는 등 설계상의 문제를 안고 있을 가능성이 큽니다. 따라서 테스트를 작성하는 과정에서 자연스럽게 코드 구조를 개선하게 되는 경우가 많습니다.
결론적으로 단위 테스트는 단순히 버그를 찾는 활동을 넘어, 프로젝트의 복잡성을 관리하고 코드의 품질을 꾸준히 유지하여 프로젝트가 장기적으로 건강하게 성장할 수 있도록 돕는 핵심적인 활동입니다.

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

단위 테스트의 목표를 달성하려면 '좋은' 테스트를 작성해야 합니다. 하지만 무엇이 좋은 테스트이고, 무엇이 좋지 않은 테스트일까요? 이는 단순히 개인의 취향 문제가 아니라, 테스트 스위트 전체의 가치를 결정하고 프로젝트의 성패에 영향을 미칠 수 있는 중요한 문제입니다.

좋은 테스트는 최소한의 유지보수 비용으로 최대의 가치를 제공해야 합니다. 여기서 가치란 주로 코드 변경 후 발생할 수 있는 버그, 즉 '회귀(Regression)'를 얼마나 잘 막아주는지로 판단할 수 있습니다. 반면, 좋지 않은 테스트는 가치는 거의 없으면서 유지보수 비용만 높은 테스트를 말합니다.

가장 대표적인 나쁜 테스트는 '깨지기 쉬운 테스트(Brittle Test)'입니다. 이런 테스트는 실제 기능은 정상적으로 동작하는데도 불구하고 코드의 내부 구현을 조금만 변경하면 실패합니다. 예를 들어, 메서드 이름을 바꾸거나 로직의 순서를 기능적 변경 없이 재배치했을 뿐인데 테스트가 실패하는 경우입니다. 이런 거짓 경고(false positive)가 잦아지면 개발자는 테스트 결과를 신뢰하지 않게 되고, 결국 테스트 스위트 전체가 방치되는 결과로 이어질 수 있습니다.

따라서 좋은 테스트는 코드의 내부 구현이 아닌, 최종적으로 나타나는 '식별 가능한 동작(Observable Behavior)'을 검증해야 합니다. 사용자가 시스템과 상호작용하여 얻게 되는 결과나, 시스템의 상태 변화처럼 외부에서 관찰할 수 있는 결과에 집중하는 것입니다. 이렇게 작성된 테스트는 리팩터링에 잘 견디면서도 실제 버그는 효과적으로 잡아낼 수 있어, 장기적으로 프로젝트에 긍정적인 영향을 줍니다.

## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

테스트 스위트의 품질을 객관적인 숫자로 파악하려는 시도에서 나온 것이 바로 커버리지 지표입니다. 커버리지는 테스트 코드가 실제 운영 코드의 얼마나 많은 부분을 실행했는지를 나타내는 척도입니다. 이는 테스트가 얼마나 철저하게 작성되었는지에 대한 하나의 단서를 제공하지만, 그 의미를 정확히 이해하고 사용해야만 가치가 있습니다.

### 1.3.1 코드 커버리지 지표에 대한 이해

가장 기본적이고 널리 알려진 커버리지 지표는 '코드 커버리지' 또는 '라인 커버리지'입니다. 이는 테스트 스위트를 실행할 때, 실제 제품 코드 중 얼마나 많은 라인이 실행되었는지를 백분율로 나타내는 지표입니다. 예를 들어, 전체 코드가 100줄인데 테스트 실행 과정에서 80줄이 호출되었다면 코드 커버리지는 80%가 됩니다. 많은 개발 도구에서 테스트 실행 후 녹색으로 표시되는 라인들이 바로 이 커버리지에 해당합니다. 이는 가장 직관적인 지표이지만, 코드의 논리적인 흐름을 모두 검증한다고 보장하지는 못하는 한계가 있습니다.

### 1.3.2 분기 커버리지 지표에 대한 이해

코드 커버리지의 한계를 보완하기 위해 등장한 것이 '분기 커버리지' 또는 '브랜치 커버리지'입니다. 코드 내의 모든 조건문과 같은 분기 지점에서 가능한 모든 결과가 테스트되었는지를 측정합니다. 예를 들어, if-else 구문이 있을 때 코드 커버리지는 if 블록만 실행해도 해당 라인들을 모두 커버한 것으로 계산할 수 있습니다. 하지만 분기 커버리지는 if가 참인 경우와 거짓인 경우(else 블록)가 모두 테스트되었을 때 비로소 해당 분기를 완전히 커버했다고 판단합니다. 따라서 분기 커버리지는 단순한 라인 커버리지보다 테스트의 철저함을 더 정확하게 나타내는 신뢰도 높은 지표라고 할 수 있습니다.

### 1.3.3 커버리지 지표에 관한 문제점

커버리지 지표는 테스트 스위트의 품질을 가늠하는 유용한 출발점이 될 수 있지만, 맹신해서는 안 되는 여러 문제점을 가지고 있습니다. 가장 큰 문제는 커버리지 숫자가 테스트의 실제 '품질'을 보장하지 않는다는 점입니다. 테스트 코드가 특정 라인을 실행했다고 해서, 그 라인의 동작을 '올바르게 검증'했다는 의미는 아닙니다. 검증문(Assertion)이 아예 없는 테스트도 커버리지는 100%로 나올 수 있습니다.

또한 커버리지 지표는 모든 코드를 동일한 중요도로 취급하는 경향이 있습니다. 복잡한 비즈니스 로직이 담긴 한 줄과, 단순히 값을 반환하는 간단한 getter 메서드의 한 줄이 커버리지 계산에서는 동일한 가치를 가집니다. 이는 개발자들이 중요하고 복잡한 로직을 테스트하는 대신, 테스트하기 쉬운 간단한 코드의 커버리지를 높이는 데 집중하게 만드는 왜곡을 낳을 수 있습니다.

### 1.3.4 특정 커버리지 숫자를 목표로 하기
많은 조직에서 '코드 커버리지 80% 달성'과 같은 구체적인 목표를 설정하곤 합니다. 하지만 이는 종종 역효과를 낳는 안티 패턴이 될 수 있습니다. 정해진 숫자를 맞추는 것이 주된 목표가 되면, 개발자들은 앞서 말한 것처럼 품질은 낮지만 커버리지만 높이는 무의미한 테스트를 양산할 가능성이 커집니다.

따라서 특정 숫자를 절대적인 목표로 삼기보다는, 커버리지 지표를 현재 상태를 진단하고 개선 방향을 찾는 참고 자료로 활용해야 합니다. 예를 들어, 새로 추가된 코드에 대한 커버리지가 현저히 낮다면 해당 부분의 테스트가 누락되었다는 신호로 받아들일 수 있습니다. 또한 전체 커버리지 수치 자체에 집착하기보다는, 커버되지 않은 코드를 주기적으로 분석하여 그 코드가 테스트가 반드시 필요한 중요한 비즈니스 로직인지, 아니면 테스트의 가치가 낮은 부분인지 판단하는 과정이 훨씬 더 중요합니다.

## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

성공적인 테스트 스위트는 단순히 높은 커버리지 숫자로 정의되지 않습니다. 그보다는 프로젝트의 생명주기 전반에 걸쳐 실질적인 가치를 제공하는 살아있는 자산이 되어야 합니다. 성공적인 테스트 스위트는 다음과 같은 세 가지 핵심 특징을 공유합니다.

### 1.4.1 개발 주기에 통합돼 있음

가장 중요한 특징은 테스트 스위트가 개발 주기의 일부로 자연스럽게 통합되어 있다는 점입니다. 테스트가 개발자의 로컬 환경에서나 CI(Continuous Integration) 서버에서나 수시로, 그리고 자동으로 실행되어야 합니다. 개발자가 코드를 변경한 직후 몇 분 안에 피드백을 받을 수 있을 때 테스트의 가치는 극대화됩니다. 만약 테스트 실행에 몇 시간씩 걸리거나, 특정 담당자만 실행할 수 있다면 테스트는 점차 외면받고 쓸모없는 존재가 될 것입니다. 빠른 피드백은 버그를 조기에 발견하여 수정 비용을 낮추고, 개발자가 자신감을 갖고 다음 작업을 진행할 수 있게 하는 핵심 요소입니다.

### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

성공적인 테스트 스위트는 100%의 코드를 테스트하려 하지 않습니다. 대신 코드베이스에서 가장 중요한 부분, 즉 핵심 비즈니스 로직과 복잡한 알고리즘을 집중적으로 테스트합니다. 모든 코드의 중요도는 같지 않습니다. 사용자의 돈을 처리하거나 복잡한 정책을 결정하는 도메인 로직은 사소한 버그 하나가 치명적인 결과를 낳을 수 있습니다. 반면, 외부 라이브러리와의 연동을 담당하는 단순한 코드나 데이터 전달만을 목적으로 하는 간단한 DTO(Data Transfer Object) 등은 상대적으로 중요도가 낮고 변경 가능성도 적습니다. 모든 코드에 동일한 노력으로 테스트를 작성하는 것은 비효율적입니다. 자원을 현명하게 사용하여 가장 가치 있는 코드에 테스트 노력을 집중하는 것이 성공적인 테스트 전략의 핵심입니다.

### 1.4.3 최소 유지비로 최대 가치를 끌어냄

결국 성공적인 테스트 스위트는 경제성의 원칙을 따릅니다. 최소한의 유지보수 비용으로 회귀 방지라는 최대의 가치를 창출해야 합니다. 앞서 언급했듯이, 내부 구현 변경에 쉽게 깨지는 취약한 테스트는 유지보수 비용만 높이는 대표적인 예입니다. 테스트 코드를 작성하고 유지하는 데 드는 시간과 노력은 모두 비용입니다. 이 비용이 테스트를 통해 얻는 이득, 즉 버그를 예방하고 리팩터링을 촉진하며 안정성을 높이는 가치보다 커서는 안 됩니다. 따라서 테스트를 작성할 때는 항상 이 테스트가 드는 비용 대비 얼마나 큰 가치를 제공하는지 고민해야 합니다. 좋은 테스트는 안정적이고, 읽기 쉬우며, 오직 중요한 이유가 있을 때만 실패함으로써 이 균형을 유지합니다.

## 1.5 이 책을 통해 배우는 것

이 책은 단순히 단위 테스트 작성법의 문법을 알려주는 것을 넘어, 실무에서 마주하는 진짜 문제들을 해결하기 위한 원칙과 패턴을 제시합니다. 독자들은 이 책을 통해 단위 테스트를 바라보는 시각을 근본적으로 바꾸고, 테스트를 프로젝트의 자산으로 만드는 구체적인 방법을 배우게 될 것입니다.

우선 단위 테스트의 본질을 깊이 있게 파고듭니다. 무엇이 단위 테스트이고, 무엇이 아닌지를 명확히 정의하며, 테스트 커뮤니티의 오랜 논쟁인 고전파와 런던파 스타일의 차이점을 실용적인 관점에서 분석합니다. 이를 통해 어떤 상황에서 어떤 접근법이 더 효과적인지 판단하는 기준을 갖게 됩니다.

다음으로 좋은 테스트가 갖춰야 할 네 가지 핵심 요소를 배우고, 이 요소들을 기준으로 테스트의 가치를 평가하는 방법을 익힙니다. 특히 테스트를 취약하게 만드는 주된 원인인 목(Mock) 객체의 오용을 방지하고, 올바르게 사용하는 전략을 자세히 다룹니다. 또한 다양한 단위 테스트 스타일과 함수형 아키텍처 같은 최신 접근법을 통해 어떻게 하면 더 견고하고 유지보수하기 쉬운 테스트를 작성할 수 있는지 살펴봅니다.

나아가 단위 테스트만으로는 검증할 수 없는 영역, 즉 데이터베이스나 메시징 큐와 같은 외부 시스템과의 연동을 다루는 통합 테스트의 중요성과 구체적인 작성 전략을 학습합니다. 마지막으로 현업에서 흔히 발견되는 단위 테스트 안티 패턴들을 정리하여, 개발자들이 쉽게 빠질 수 있는 함정들을 피할 수 있도록 돕습니다.

이 모든 과정은 스프링 백엔드 개발자의 현실적인 고민에 초점을 맞추어 진행됩니다. 독자들은 이 책을 끝까지 읽고 나면, 어떤 테스트를 작성해야 하고 어떤 테스트는 작성하지 말아야 할지 스스로 판단할 수 있는 능력을 갖추게 될 것입니다.
