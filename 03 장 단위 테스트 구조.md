좋은 테스트는 그 내용뿐만 아니라 구조적으로도 잘 정리되어 있어야 합니다. 잘 짜인 구조는 테스트의 가독성을 높여 다른 개발자가 테스트의 의도를 쉽게 파악할 수 있게 하고, 이는 곧 테스트 스위트 전체의 유지보수성을 향상시키는 결과로 이어집니다. 반대로 구조가 복잡하고 일관성이 없는 테스트는 이해하기 어려워 아무도 수정하려 하지 않는 방치된 코드가 되기 쉽습니다.

이 장에서는 좋은 단위 테스트가 가져야 할 이상적인 구조에 대해 알아봅니다. 테스트 코드를 명확하게 구성하는 AAA 패턴부터 시작하여, 테스트의 재사용성을 높이는 방법, 그리고 가독성 좋은 테스트 이름을 짓는 규칙까지, 테스트의 품질을 한 단계 끌어올릴 수 있는 구체적이고 실용적인 기법들을 소개합니다. 이러한 기법들은 테스트를 더 견고하고 이해하기 쉽게 만들어, 장기적으로 프로젝트의 건강성에 기여할 것입니다.

## 3.1 단위 테스트를 구성하는 방법

단위 테스트 코드는 제품 코드와 마찬가지로 명확하고 읽기 쉬워야 합니다. 테스트의 목적은 특정 조건에서 시스템의 한 단위가 어떻게 동작하는지를 문서화하고 검증하는 것입니다. 따라서 다른 사람이 테스트 코드를 보았을 때, 어떤 시나리오를 테스트하는지, 무엇을 검증하려 하는지를 한눈에 파악할 수 있어야 합니다. 이를 위해 오랫동안 검증되고 널리 사용되는 몇 가지 패턴과 원칙이 있습니다.

### 3.1.1 AAA 패턴 사용

단위 테스트를 구조화하는 가장 보편적이고 효과적인 방법은 AAA(Arrange, Act, Assert) 패턴을 따르는 것입니다. 이 패턴은 테스트 코드를 논리적인 세 단계로 나누어 구성의 일관성을 부여하고 가독성을 높여줍니다.

- 준비(Arrange): 이 단계에서는 테스트에 필요한 모든 것을 설정합니다. 테스트 대상 객체(SUT, System Under Test)를 생성하고, 필요한 의존성을 설정하며, 테스트에 사용될 입력 데이터를 만듭니다. 즉, 테스트를 실행하기 위한 전제 조건을 만드는 과정입니다. 준비 단계의 코드는 테스트의 핵심 로직이라기보다는 사전 준비 작업에 해당합니다.
- 실행(Act): 이 단계에서는 테스트하려는 동작을 실제로 수행합니다. 일반적으로 테스트 대상 객체의 메서드를 단 한 번 호출하는 것으로 이루어집니다. 이 호출을 통해 시스템의 상태가 변경되거나 어떤 결과값이 반환됩니다. 실행 단계는 테스트의 핵심이며, 가장 중요한 부분입니다.
- 검증(Assert): 이 단계에서는 실행 단계의 결과가 예상대로인지를 확인합니다. 실행된 메서드가 반환한 값이 기대값과 일치하는지, 또는 시스템의 상태가 원하는 대로 변경되었는지를 검증문(Assertion)을 통해 확인합니다. 검증 단계의 결과(성공 또는 실패)가 곧 해당 테스트 케이스의 결과가 됩니다.

이 세 단계를 코드에서 명확히 구분하면 테스트의 흐름을 따라가기 매우 쉬워집니다. 많은 개발자가 각 단계 앞에 주석(// Arrange, // Act, // Assert)을 달거나, 각 단계를 빈 줄로 분리하여 시각적으로 구분하는 방식을 선호합니다. 이 간단한 규칙을 따르는 것만으로도 테스트 코드의 품질을 크게 향상시킬 수 있습니다.

### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

단위 테스트는 하나의 시나리오, 즉 하나의 논리적인 개념만을 검증해야 합니다. 이 원칙을 지키기 위한 중요한 실천 방안은 하나의 테스트 메서드 안에 여러 개의 실행(Act)과 검증(Assert) 구절이 번갈아 나타나는 것을 피하는 것입니다. 이는 테스트가 한 번에 너무 많은 것을 하려고 한다는 좋지 않은 신호입니다.

이러한 구조는 여러 가지 문제를 야기합니다. 첫째, 테스트의 핵심 의도가 무엇인지 파악하기 어려워 가독성을 해칩니다. 둘째, 실패 원인 파악을 어렵게 만듭니다. 만약 첫 번째 검증문에서 테스트가 실패하면, 그 뒤에 있는 다른 검증 로직들은 실행조차 되지 않아 전체적인 실패 상황을 한 번에 알 수 없습니다. 이는 버그를 수정하는 과정을 번거롭게 만듭니다.

가장 좋은 해결책은 이러한 테스트를 여러 개의 개별 테스트로 분리하는 것입니다. 각 테스트는 명확한 하나의 AAA 구조를 가져야 합니다. 예를 들어, 사용자를 생성하고 그 사용자의 이름을 변경하는 두 가지 동작을 하나의 테스트에서 검증하려 했다면, 이를 '사용자 생성 기능 테스트'와 '사용자 이름 변경 기능 테스트'라는 두 개의 독립된 테스트로 나누어야 합니다. 이렇게 하면 각 테스트는 하나의 책임만을 갖게 되어 훨씬 이해하고 관리하기 쉬워집니다.

### 3.1.3 테스트 내 if 문 피하기

좋은 단위 테스트는 조건부 논리, 특히 if 문을 포함해서는 안 됩니다. 테스트는 결정론적이어야 합니다. 즉, 주어진 동일한 조건에서는 항상 동일한 경로를 실행하고 동일한 결과를 내야 합니다. if 문은 테스트 코드 내에 여러 실행 경로를 만들어 이 원칙을 위반하며, 이는 하나의 테스트 메서드가 사실상 두 개 이상의 시나리오를 한 번에 테스트하고 있다는 명백한 신호입니다.
테스트 코드에 if 문이 있다는 것은 그 테스트의 목적이 불분명하다는 것을 의미합니다. 테스트를 읽는 사람은 어떤 조건에서 어떤 검증이 이루어지는지 파악하기 위해 if 문의 논리를 따라가야만 합니다. 또한 테스트가 실패했을 때, 어떤 분기를 타서 실패했는지 즉시 알기 어려워 디버깅을 복잡하게 만듭니다.

if 문으로 분기해서 처리하고 싶은 각 시나리오에 대해서는 별도의 독립된 테스트 메서드를 작성하는 것이 올바른 접근법입니다. 예를 들어, '입력값이 유효할 때'와 '입력값이 null일 때'를 테스트해야 한다면, 이 두 가지 경우를 위한 두 개의 분리된 테스트를 만들어야 합니다. 각 테스트의 이름에 해당 시나리오를 명시하면(예: whenInputIsValid_thenSuccess, whenInputIsNull_thenThrowException), 테스트의 의도가 명확해지고 코드의 가독성이 크게 향상됩니다.

### 3.1.4 각 구절은 얼마나 커야 하는가?

AAA 패턴의 각 구절은 이상적인 크기가 있습니다. 이 가이드라인을 따르는 것은 테스트의 명확성을 유지하는 데 도움이 됩니다.

준비(Arrange) 구절은 테스트에 따라 길이가 달라질 수 있으며, 때로는 세 구절 중 가장 길어질 수 있습니다. 복잡한 객체를 생성하거나 여러 협력 객체의 동작을 설정해야 하는 경우, 준비 코드는 자연스럽게 늘어납니다. 준비 구절이 지나치게 길고 복잡하다면, 이는 테스트 대상 클래스가 너무 많은 의존성을 가지고 있다는 신호일 수 있으므로 코드 설계를 다시 한번 검토해볼 필요가 있습니다. 하지만 준비 구절 자체가 길다는 것이 반드시 나쁜 것은 아닙니다. 중요한 것은 가독성을 해치지 않도록 관리하는 것이며, 이는 뒤에서 다룰 헬퍼 메서드나 빌더 패턴을 통해 개선할 수 있습니다.

실행(Act) 구절은 극도로 짧아야 합니다. 가장 이상적인 실행 구절은 테스트 대상 메서드를 호출하는 단 한 줄의 코드로 이루어집니다. 이는 단위 테스트가 단 하나의 동작, 단 하나의 책임에만 집중해야 한다는 원칙을 반영합니다. 만약 실행 구절에 여러 줄의 코드가 필요하다고 느껴진다면, 해당 테스트가 너무 많은 것을 검증하려 하고 있을 가능성이 높으며, 여러 개의 테스트로 분리하는 것을 고려해야 합니다.

검증(Assert) 구절의 길이는 검증하려는 내용에 따라 달라집니다. 단일 값을 확인하는 한 줄의 검증문이 될 수도 있고, 객체의 여러 속성을 확인하는 여러 줄의 검증문이 될 수도 있습니다. 중요한 것은 검증문의 개수 자체가 아니라, 모든 검증문이 실행 구절에서 일어난 '단일한 결과'를 검증하는 데 집중되어야 한다는 점입니다.

### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가

개발 커뮤니티에는 "테스트 메서드당 하나의 검증문만 사용하라"는 오래된 조언이 있습니다. 이는 테스트가 오직 한 가지에만 집중하도록 강제하려는 좋은 의도에서 비롯된 지침이지만, 너무 문자 그대로 해석하면 오히려 비효율적이고 가독성이 떨어지는 테스트를 만들 수 있습니다.

예를 들어, 사용자 생성 기능을 테스트한다고 가정해 봅시다. 생성된 사용자 객체가 올바른지 확인하려면 사용자의 이름, 이메일, 초기 상태 등 여러 속성을 검증해야 할 수 있습니다. 이 규칙을 맹목적으로 따르면, 이름 검증 테스트, 이메일 검증 테스트, 상태 검증 테스트 등 세 개의 별도 테스트를 만들어야 합니다. 이는 불필요한 코드 중복을 낳고, '사용자 객체가 올바르게 생성되었다'는 하나의 논리적 개념을 여러 테스트에 흩어놓아 전체적인 그림을 파악하기 어렵게 만듭니다.

더 나은 원칙은 '하나의 테스트에서는 하나의 논리적 개념만을 검증하라'는 것입니다. 실행(Act) 구절에서 수행된 한 가지 동작의 결과를 온전히 확인하기 위해서라면 여러 개의 검증문을 사용하는 것이 타당하고 바람직합니다. 사용자 생성 예시의 경우, 생성된 사용자 객체의 여러 속성을 하나의 테스트 메서드 안에서 모두 검증하는 것이 훨씬 더 논리적이고 실용적입니다. 핵심은 모든 검증문이 단일한 시나리오의 결과라는 하나의 큰 그림을 확인하는 데 기여해야 한다는 점입니다. 만약 서로 관련 없는 두 가지 결과를 한 테스트에서 검증하려 한다면, 그때는 테스트를 분리해야 합니다.

### 3.1.6 종료 단계는 어떤가

일부 테스트 프레임워크는 테스트 실행 후 자원을 정리하기 위한 종료(Teardown) 단계를 지원합니다. 이는 보통 @AfterEach 나 @AfterAll 같은 어노테이션을 통해 구현됩니다. 이 단계는 테스트 중에 생성된 파일이나 데이터베이스 레코드, 열려있는 네트워크 연결 등 공유 자원을 정리하여 다음 테스트에 영향을 주지 않도록 하기 위해 사용됩니다.

하지만 잘 설계된 단위 테스트에서는 종료 단계가 거의 필요하지 않습니다. 좋은 단위 테스트는 데이터베이스나 파일 시스템과 같은 프로세스 외부의 공유 자원에 의존하지 않기 때문입니다. 모든 의존성은 메모리 내에서 동작하는 객체이거나 테스트 대역으로 대체되어야 합니다. 이런 테스트는 실행이 끝나면 가비지 컬렉터에 의해 모든 관련 객체가 메모리에서 자동으로 정리되므로, 개발자가 수동으로 자원을 해제할 필요가 없습니다.

만약 테스트에서 종료 단계를 필수로 사용하고 있다면, 그것은 단위 테스트가 아닌 통합 테스트를 작성하고 있을 가능성이 높다는 신호입니다. 통합 테스트의 세계에서는 데이터베이스 상태를 원상 복구하는 등의 이유로 종료 단계가 중요하고 유용하게 사용됩니다. 그러나 순수한 단위 테스트를 작성하는 것을 목표로 한다면, 종료 단계의 필요성을 최소화하거나 없애는 방향으로 테스트를 설계해야 합니다.

### 3.1.7 테스트 대상 시스템 구별하기

테스트 코드를 읽을 때, 어떤 객체가 이 테스트의 주인공, 즉 '테스트 대상 시스템(SUT, System Under Test)'인지 한눈에 파악할 수 있어야 합니다. SUT는 테스트의 준비(Arrange) 단계에서 설정되고 실행(Act) 단계에서 호출되는 핵심 객체입니다.

SUT를 명확히 구별하는 간단하고 효과적인 방법은 변수명에 일관된 규칙을 적용하는 것입니다. 예를 들어, 모든 SUT 변수 이름을 sut로 통일하는 것입니다. Calculator 클래스를 테스트한다면 Calculator calculator = new Calculator(); 대신 Calculator sut = new Calculator(); 라고 선언하는 식입니다.

이 규칙을 적용하면 코드를 읽는 누구나 sut라는 변수명을 보고 "아, 이 객체가 바로 이 테스트가 검증하려는 대상이구나"라고 즉시 인지할 수 있습니다. 다른 협력 객체(목, 스텁 등)들은 그 역할에 맞는 명확한 이름을 붙여주면 SUT와의 관계가 더욱 명확해집니다. 이처럼 간단한 명명 규칙 하나만으로도 테스트 코드의 가독성과 의도 전달력을 크게 향상시킬 수 있습니다.

### 3.1.8 준비, 실행, 검증 주석 제거하기

앞서 AAA 패턴을 소개하면서 각 구절을 주석이나 빈 줄로 구분하는 것이 좋다고 언급했습니다. 이는 테스트 구조를 처음 배우는 단계에서는 매우 유용한 방법입니다. 하지만 테스트 작성에 익숙해지고, 각 구절의 크기를 이상적으로 유지하는 원칙들을 잘 따르게 되면, 이러한 명시적인 주석은 점차 불필요해집니다.

잘 작성된 테스트는 그 구조 자체가 AAA 패턴을 시각적으로 드러냅니다. 준비 구절은 객체 생성과 설정 코드로 이루어져 있고, 실행 구절은 단 한 줄의 SUT 메서드 호출로 나타나며, 검증 구절은 assertThat이나 assertEquals 같은 검증문으로 시작됩니다. 이처럼 코드가 패턴을 스스로 설명하게 되면, // Arrange, // Act, // Assert 와 같은 주석은 오히려 불필요한 잡음(noise)이 될 수 있습니다.

궁극적인 목표는 주석 없이도 코드의 구조와 의도가 명확하게 드러나는 테스트를 작성하는 것입니다. 따라서 AAA 패턴의 원칙을 충분히 내재화했다면, 가독성을 해치지 않는 선에서 점진적으로 주석을 제거해나가는 것을 고려해볼 수 있습니다.

## 3.2 xUnit 테스트 프레임워크 살펴보기

우리가 지금까지 논의한 단위 테스트 구조와 원칙들은 특정 도구에 종속되지 않는 보편적인 개념입니다. 하지만 이러한 개념을 실제 코드로 구현하기 위해서는 테스트 프레임워크의 도움이 필요합니다. 자바와 스프링 생태계에서는 JUnit이 사실상의 표준으로 사용되며, JUnit은 xUnit이라는 더 큰 테스트 프레임워크 계열의 일원입니다. xUnit은 스몰토크(Smalltalk) 언어의 SUnit에서 시작하여 다양한 언어(NUnit for .NET, PyUnit for Python 등)로 파생된 프레임워크들의 집합을 총칭하는 용어입니다.

이들 xUnit 프레임워크는 공통적인 설계 철학과 구조를 공유하며, 개발자가 테스트를 효율적으로 작성하고 실행할 수 있도록 돕는 여러 핵심 기능을 제공합니다.

첫째, **테스트 러너(Test Runner)** 기능입니다. 테스트 러너는 코드베이스 내에서 어떤 메서드가 테스트 메서드인지를 식별하고, 그것들을 실행한 뒤 결과를 종합하여 보여주는 역할을 합니다. 개발자가 직접 main 메서드를 만들어 각 테스트를 일일이 호출할 필요 없이, 간단한 어노테이션(Annotation) 하나만 붙이면 프레임워크가 알아서 테스트를 발견하고 실행해 줍니다. JUnit에서는 @Test 어노테이션이 바로 이 역할을 합니다.

둘째, **테스트 픽스처(Test Fixture)** 관리 기능입니다. 테스트 픽스처란 테스트를 실행하는 데 필요한 정해진 상태나 환경을 의미합니다. 여기에는 객체 생성, 데이터 초기화 등이 포함됩니다. xUnit 프레임워크는 모든 테스트가 실행되기 전이나 후에 공통된 준비 또는 정리 작업을 수행할 수 있도록 @BeforeEach, @AfterEach, @BeforeAll, @AfterAll과 같은 어노테이션을 제공합니다. 이는 AAA 패턴의 준비(Arrange) 단계를 효율적으로 구성하고, 각 테스트가 서로에게 영향을 주지 않는 독립적인 환경에서 실행될 수 있도록 보장하는 데 매우 중요한 역할을 합니다.

셋째, **검증문(Assertion)** 라이브러리입니다. 테스트의 검증(Assert) 단계에서는 실행 결과가 예상과 같은지 확인해야 합니다. xUnit 프레임워크는 assertEquals(), assertTrue(), assertNotNull() 등과 같이 결과를 쉽게 비교하고 검증할 수 있는 다양한 정적 메서드들을 제공합니다. 만약 검증이 실패하면, 이 메서드들은 테스트를 즉시 중단시키고 실패 정보를 담은 예외를 던져 테스트 러너가 실패를 인지하고 보고할 수 있도록 합니다.

이처럼 xUnit 프레임워크는 단위 테스트의 구조화와 자동화를 위한 필수적인 기반을 제공합니다. 개발자는 프레임워크가 제공하는 잘 정립된 구조 위에서 테스트의 핵심 로직, 즉 비즈니스 시나리오를 검증하는 데에만 집중할 수 있습니다.

### 3.3 테스트 간 테스트 픽스처 재사용

테스트 코드를 작성하다 보면 여러 테스트에서 동일하거나 유사한 객체를 생성하고 설정해야 하는 경우가 자주 발생합니다. 예를 들어, 사용자 관련 기능을 테스트할 때마다 `User` 객체를 생성해야 할 수 있습니다. 이때 많은 개발자가 코드 중복을 피하기 위해 이러한 준비 과정을 한곳에 모아 재사용하려는 시도를 합니다. 이 준비 과정, 즉 테스트를 실행하기 위해 필요한 모든 것(객체, 데이터, 의존성 등)의 묶음을 **테스트 픽스처(Test Fixture)**라고 부릅니다.

테스트 픽스처를 재사용하는 것은 코드의 양을 줄여준다는 장점이 있지만, 잘못된 방식으로 재사용하면 테스트의 독립성을 해치고 가독성을 떨어뜨리는 심각한 부작용을 낳을 수 있습니다.

### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다

가장 피해야 할 최악의 픽스처 재사용 방법은 여러 테스트가 **하나의 픽스처 인스턴스를 공유**하는 것입니다. 예를 들어, 테스트 클래스의 정적(static) 필드에 픽스처 객체를 만들어 놓고 모든 테스트 메서드가 이를 함께 사용하는 경우입니다.

이러한 방식은 테스트들을 서로 강하게 결합시킵니다. 어떤 테스트 하나가 공유된 픽스처의 상태를 변경하면, 그 변경이 다음에 실행되는 다른 모든 테스트에 영향을 미칩니다. 이로 인해 테스트는 실행 순서에 따라 성공하거나 실패하는 예측 불가능한 상태가 됩니다. 예를 들어, `testA`가 공유 사용자 객체의 상태를 '비활성'으로 바꿨다면, '활성' 상태를 가정하고 만들어진 `testB`는 `testA`가 먼저 실행될 때만 실패하게 됩니다.

이러한 문제는 버그의 원인을 찾기 매우 어렵게 만들고, 테스트 스위트 전체의 신뢰도를 무너뜨립니다. 좋은 테스트의 핵심 원칙 중 하나는 **독립성(Isolation)**입니다. 각 테스트는 다른 어떤 테스트에도 영향을 받지 않고, 자신만의 고유한 환경에서 실행되어야 합니다. 공유된 픽스처 인스턴스를 사용하는 것은 이 원칙을 정면으로 위반하는 대표적인 안티 패턴입니다.

### 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용

테스트 간의 결합 문제를 피하면서 코드 중복을 줄이기 위해 가장 흔하게 사용되는 방법은 JUnit의 `@BeforeEach` 어노테이션(또는 테스트 클래스의 생성자)을 활용하는 것입니다. `@BeforeEach`가 붙은 메서드는 각각의 `@Test` 메서드가 실행되기 직전에 매번 호출되므로, 모든 테스트는 항상 새로운 픽스처 인스턴스를 받아 독립성을 보장받을 수 있습니다.

이 방법은 기술적으로는 올바르며 테스트의 독립성을 해치지 않습니다. 하지만 **가독성** 측면에서 중요한 단점을 가집니다. 테스트 픽스처를 설정하는 준비(Arrange) 코드가 실제 테스트 로직이 담긴 `@Test` 메서드와 물리적으로 분리되기 때문입니다.

어떤 테스트 메서드의 동작을 이해하기 위해, 개발자는 해당 메서드뿐만 아니라 `@BeforeEach` 메서드까지 거슬러 올라가 코드를 확인해야만 합니다. 테스트 시나리오가 간단할 때는 큰 문제가 아닐 수 있지만, 여러 종류의 픽스처가 복잡하게 설정되는 경우, 테스트의 전체 맥락을 파악하기 위해 여러 곳을 오가야 하는 인지적 부담이 발생합니다. 이는 AAA 패턴이 주는 '한눈에 파악되는 흐름'이라는 장점을 훼손하며, 결국 테스트의 유지보수를 어렵게 만드는 요인이 됩니다.

### 3.3.3 더 나은 테스트 픽스처 재사용법

코드의 중복을 피하면서도 각 테스트의 가독성과 독립성을 모두 지키는 더 나은 방법이 있습니다. 바로 테스트 클래스 내에 **비공개 헬퍼 메서드(private helper method)** 또는 **팩토리 메서드(factory method)**를 활용하는 것입니다.

이 접근법은 픽스처를 생성하는 '로직'은 헬퍼 메서드에 모아서 재사용하되, 실제 픽스처 '인스턴스화'는 각 테스트 메서드 내의 준비(Arrange) 구절에서 명시적으로 호출하는 방식입니다.

예를 들어, 여러 테스트에서 `User` 객체가 필요하다면 `@BeforeEach`에서 `user` 필드를 초기화하는 대신, 다음과 같은 헬퍼 메서드를 만듭니다.

```java
private User createDefaultUser() {
    return new User("testuser", "test@email.com", true);
}
```

그리고 각 테스트 메서드 안에서는 이 헬퍼 메서드를 직접 호출하여 픽스처를 준비합니다.

```java
@Test
void testUserActivation() {
    // Arrange
    User sut = createDefaultUser(); 

    // Act
    sut.activate();

    // Assert
    assertTrue(sut.isActive());
}
```

이 방식은 여러 장점을 가집니다. 첫째, `createDefaultUser`라는 메서드 이름 자체가 무엇을 생성하는지 명확히 알려주므로 가독성이 높습니다. 둘째, 모든 준비 과정이 테스트 메서드 내에 위치하므로, 개발자는 다른 곳을 찾아볼 필요 없이 해당 테스트의 전체 시나리오를 한 번에 파악할 수 있습니다. 셋째, 코드 중복이 제거됩니다. 넷째, 특정 시나리오를 위한 변형이 필요할 때 헬퍼 메서드에 매개변수를 추가하여 유연하게 대처할 수 있습니다(예: `createUser(boolean isActive)`).

결론적으로, 헬퍼 메서드를 사용하는 방식은 `@BeforeEach`의 단점인 가독성 저하를 피하면서도 코드 재사용이라는 장점을 취할 수 있는 가장 균형 잡힌 전략입니다.

### 3.4 단위 테스트 명명법

테스트의 이름은 그 테스트의 목적을 요약하는 가장 중요한 단서입니다. 잘 지은 테스트 이름은 그 자체로 하나의 문서 역할을 하여, 코드를 처음 보는 사람도 무엇을 테스트하는지 즉시 이해할 수 있게 도와줍니다. 반면, `test1`이나 `testCalculate`처럼 모호하고 일반적인 이름은 테스트의 의도를 전혀 설명하지 못하며, 실패했을 때 어떤 기능에 문제가 생긴 것인지 파악하는 데 불필요한 시간을 소모하게 만듭니다.

테스트 이름은 단순히 테스트를 구분하는 식별자를 넘어, 시스템의 동작 사양을 설명하는 역할을 해야 합니다. 테스트 러너가 실행 결과를 보여줄 때, 잘 지어진 테스트 이름들의 목록은 그 자체로 우리 시스템이 제공하는 기능 명세서처럼 보일 수 있습니다. 따라서 테스트 명명에는 제품 코드를 작성할 때와 마찬가지로 신중한 고민과 일관된 규칙이 필요합니다.

### 3.4.1 단위 테스트 명명 지침

가독성 높고 유용한 테스트 이름을 짓기 위한 효과적인 지침은 테스트의 세 가지 핵심 요소를 이름에 모두 포함하는 것입니다.

1. **테스트 대상 메서드 또는 기능 단위의 이름 (The name of the method or unit of work being tested)**: 무엇을 테스트하고 있는가? 이는 보통 테스트 대상 시스템(SUT)의 특정 메서드 이름이 됩니다. 이를 통해 이 테스트가 시스템의 어떤 부분과 관련 있는지 명확히 알 수 있습니다.

2. **테스트가 진행되는 시나리오 또는 조건 (The scenario or condition under which the test is run)**: 어떤 상황에서 테스트하는가? 이는 테스트의 준비(Arrange) 구절에서 설정하는 핵심적인 조건을 설명합니다. 예를 들어 '입력값이 유효할 때', '사용자가 비활성 상태일 때', '재고가 부족할 때' 등이 해당됩니다.

3. **기대하는 결과 또는 동작 (The expected outcome or behavior)**: 그래서 어떻게 되어야 하는가? 이는 검증(Assert) 구절에서 확인하고자 하는 기대 결과를 명시합니다. '예외가 발생해야 함', '사용자 상태가 활성으로 변경되어야 함', '주문이 성공적으로 생성되어야 함'과 같이 예상되는 동작이나 상태 변화를 설명합니다.

이 세 가지 요소를 조합하여 `[테스트 대상]_[시나리오]_[기대 결과]` 형식으로 이름을 만드는 것이 널리 쓰이는 매우 효과적인 규칙입니다. 각 부분은 밑줄(underscore)로 구분하여 가독성을 높일 수 있습니다. 이 규칙을 따르면 길지만 매우 서술적인 이름을 만들 수 있으며, 이는 테스트의 가치를 크게 향상시킵니다.

### 3.4.2 예제: 지침에 따른 테스트 이름 변경

실제 예를 통해 이 명명 지침을 어떻게 적용하는지 살펴보겠습니다. 숫자를 더하는 간단한 `Calculator` 클래스의 `add` 메서드를 테스트한다고 가정해 봅시다.

처음에는 다음과 같이 모호한 이름으로 테스트를 작성할 수 있습니다.

```java
@Test
void testAdd() {
    // ...
}
```

이 이름은 아무것도 설명해주지 않습니다. 이 테스트가 실패하면, 우리는 `add` 메서드에 문제가 있다는 것 외에는 아무 정보도 얻을 수 없습니다.

이제 명명 지침을 적용하여 이 테스트의 이름을 개선해 보겠습니다. 먼저, 두 개의 양수를 더하는 가장 기본적인 시나리오를 테스트하는 경우입니다.

* **테스트 대상**: `add` 메서드
* **시나리오**: `두_양수가_주어졌을_때` (whenTwoPositiveNumbersAreGiven)
* **기대 결과**: `그_합을_반환해야_함` (shouldReturnTheirSum)

이를 조합하면 다음과 같은 명확한 테스트 이름이 만들어집니다.

```java
@Test
void add_whenTwoPositiveNumbersAreGiven_shouldReturnTheirSum() {
    // Arrange
    Calculator sut = new Calculator();

    // Act
    int result = sut.add(2, 3);

    // Assert
    assertEquals(5, result);
}
```

이번에는 음수를 더하는 시나리오를 테스트해 보겠습니다.

* **테스트 대상**: `add` 메서드
* **시나리오**: `하나의_양수와_하나의_음수가_주어졌을_때` (whenOnePositiveAndOneNegativeNumberAreGiven)
* **기대 결과**: `그_합을_반환해야_함` (shouldReturnTheirSum)

이를 반영한 테스트 이름은 다음과 같습니다.

```java
@Test
void add_whenOnePositiveAndOneNegativeNumberAreGiven_shouldReturnTheirSum() {
    // Arrange
    Calculator sut = new Calculator();

    // Act
    int result = sut.add(5, -2);

    // Assert
    assertEquals(3, result);
}
```

이렇게 명확한 이름을 사용하면, 테스트가 실패했을 때 `add_whenOnePositiveAndOneNegativeNumberAreGiven_shouldReturnTheirSum` 라는 이름만 보고도 "아, 양수와 음수를 더하는 시나리오에서 문제가 발생했구나"라고 즉시 파악할 수 있습니다. 이는 디버깅 시간을 단축시키고, 테스트 스위트를 살아있는 문서로 만드는 핵심적인 습관입니다.

### 3.5 매개변수화된 테스트 리팩터링하기

앞선 명명법 예제에서 우리는 계산기의 `add` 메서드를 위해 여러 테스트를 만들었습니다. `add_whenTwoPositiveNumbersAreGiven...`과 `add_whenOnePositiveAndOneNegativeNumberAreGiven...` 같은 테스트들은 비록 시나리오는 다르지만, 그 내부 구조는 거의 동일합니다. 즉, 두 개의 숫자를 입력받아 `add` 메서드를 호출하고 그 결과를 예상값과 비교하는 로직이 중복됩니다.

이처럼 테스트의 핵심 로직은 같고 입력값과 기대값만 달라지는 경우가 빈번하게 발생합니다. 이럴 때 각 시나리오마다 새로운 테스트 메서드를 복사해서 붙여넣는 방식은 코드 중복을 늘리고 유지보수를 어렵게 만듭니다. 새로운 테스트 케이스를 추가하거나 기존 로직을 수정해야 할 때 모든 관련 테스트를 일일이 찾아 고쳐야 하기 때문입니다.

이러한 문제를 해결하는 우아한 방법이 바로 **매개변수화된 테스트(Parameterized Test)**를 사용하는 것입니다. 이는 하나의 테스트 메서드 템플릿을 만들어 놓고, 다양한 입력값과 기대값의 조합을 전달하여 여러 번 실행하는 기법입니다. JUnit 5는 이 기능을 강력하게 지원하며, 이를 통해 테스트 코드를 훨씬 더 간결하고 효율적으로 리팩터링할 수 있습니다.

### 3.5.1 매개변수화된 테스트를 위한 데이터 생성

매개변수화된 테스트를 작성하려면 먼저, 테스트에 사용할 데이터 묶음들을 제공해야 합니다. JUnit 5는 `@CsvSource`, `@ValueSource`, `@MethodSource` 등 다양한 어노테이션을 통해 데이터를 손쉽게 주입할 수 있는 방법을 제공합니다. 그중 `@CsvSource`는 간단한 값을 CSV(Comma-Separated Values) 형식의 문자열로 직접 제공할 수 있어 가장 직관적이고 편리한 방법 중 하나입니다.

앞서 작성했던 `Calculator` 테스트를 매개변수화된 테스트로 리팩터링해 보겠습니다. 기존의 두 테스트 메서드를 하나의 매개변수화된 테스트로 통합할 수 있습니다.

**리팩터링 전:**

```java
@Test
void add_whenTwoPositiveNumbersAreGiven_shouldReturnTheirSum() {
    Calculator sut = new Calculator();
    int result = sut.add(2, 3);
    assertEquals(5, result);
}

@Test
void add_whenOnePositiveAndOneNegativeNumberAreGiven_shouldReturnTheirSum() {
    Calculator sut = new Calculator();
    int result = sut.add(5, -2);
    assertEquals(3, result);
}
```

**리팩터링 후:**

```java
@ParameterizedTest(name = "[{index}] {0} + {1} = {2}")
@CsvSource({
    "2, 3, 5",      // 두 양수를 더하는 시나리오
    "5, -2, 3",     // 양수와 음수를 더하는 시나리오
    "-2, -4, -6",   // 두 음수를 더하는 시나리오
    "0, 0, 0"       // 두 개의 0을 더하는 시나리오
})
void add_returnsSumOfTwoNumbers(int a, int b, int expectedSum) {
    // Arrange
    Calculator sut = new Calculator();

    // Act
    int result = sut.add(a, b);

    // Assert
    assertEquals(expectedSum, result);
}
```

이 리팩터링을 통해 몇 가지 중요한 개선이 이루어졌습니다. 먼저, `@Test` 대신 `@ParameterizedTest` 어노테이션을 사용했습니다. 그리고 `@CsvSource`를 통해 테스트에 사용할 여러 데이터 묶음(입력값 `a`, `b`와 기대값 `expectedSum`)을 제공했습니다. JUnit은 `@CsvSource`의 각 라인을 읽어 `add_returnsSumOfTwoNumbers` 메서드를 여러 번 호출하며, 이때 각 값을 메서드의 매개변수 `a`, `b`, `expectedSum`에 자동으로 주입해 줍니다.

이를 통해 테스트 로직의 중복이 완벽하게 제거되었습니다. 이제 새로운 덧셈 시나리오를 추가하고 싶다면 `@CsvSource`에 단순히 새로운 데이터 라인 한 줄만 추가하면 됩니다.

또한 `@ParameterizedTest`의 `name` 속성을 사용하여 각 테스트 실행에 대한 동적인 이름을 지정했습니다. `{index}`는 실행 순서를, `{0}`, `{1}`, `{2}`는 각각 첫 번째, 두 번째, 세 번째 매개변수를 의미합니다. 덕분에 테스트 실행 결과 창에는 `[1] 2 + 3 = 5`, `[2] 5 + -2 = 3` 과 같이 각 시나리오가 명확하게 표시되어 가독성과 디버깅 편의성을 크게 높일 수 있습니다.

## 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상

테스트의 마지막 단계인 검증(Assert)은 테스트의 성공 여부를 판가름하는 결정적인 부분입니다. JUnit은 `assertEquals`, `assertTrue`, `assertNotNull` 등 기본적인 검증 메서드들을 제공하며, 이들만으로도 기능을 검증하는 데는 아무런 문제가 없습니다. 하지만 이 기본 검증문들은 때때로 가독성이 떨어지거나, 개발자의 실수를 유발하는 함정을 가지고 있습니다.

예를 들어, `assertEquals(expected, actual)` 메서드는 '기대값'을 첫 번째 인자로, '실제값'을 두 번째 인자로 받습니다. 하지만 많은 개발자가 이 순서를 헷갈려서 반대로 쓰는 실수를 저지릅니다. 이런 실수는 테스트가 실패했을 때 출력되는 오류 메시지를 오해하게 만들어 디버깅을 더욱 혼란스럽게 만듭니다.

이러한 단점을 보완하고 테스트 코드의 가독성을 극적으로 향상시키기 위해 등장한 것이 **유창한(fluent) 검증문 라이브러리**입니다. 자바 생태계에서는 AssertJ가 가장 널리 쓰이는 표준적인 라이브러리입니다. 유창한 검증문 라이브러리는 마치 자연스러운 영어 문장을 읽는 것처럼 코드를 작성할 수 있게 해 줍니다.

기본 JUnit 검증문과 AssertJ를 비교해 보겠습니다.

**기본 JUnit 검증문:**

```java
// assertEquals(기대값, 실제값) 순서를 기억해야 한다.
assertEquals(5, result);
assertTrue(user.isActive());
assertNotNull(user);
```

**AssertJ를 사용한 유창한 검증문:**

```java
import static org.assertj.core.api.Assertions.assertThat;

// assertThat(실제값)으로 시작하여 자연스러운 문장처럼 이어진다.
assertThat(result).isEqualTo(5);
assertThat(user.isActive()).isTrue();
assertThat(user).isNotNull();
```

AssertJ의 `assertThat(실제값).기대동작(기대값)` 구조는 훨씬 더 직관적이고 읽기 쉽습니다. 인자의 순서를 헷갈릴 염려가 없으며, 코드가 스스로 무엇을 검증하는지 명확하게 설명합니다.

또한 AssertJ는 최신 IDE의 자동 완성 기능과 결합될 때 강력한 시너지를 발휘합니다. `assertThat(user).`까지만 입력하면 IDE가 `user` 객체에 적용할 수 있는 수많은 검증 메서드 목록(`hasName()`, `isActive()`, `isInstanceOf()` 등)을 추천해 줍니다. 이는 개발자가 모든 검증 메서드를 외울 필요 없이, 필요한 검증 로직을 쉽고 빠르게 찾아 쓸 수 있게 도와줍니다.

더 나아가 컬렉션이나 복잡한 객체를 검증할 때 AssertJ는 훨씬 더 풍부하고 강력한 기능을 제공하여, 복잡한 검증 로직을 매우 간결하고 명확하게 표현할 수 있도록 해줍니다. 이처럼 가독성과 개발 편의성을 크게 높여주므로, 현대적인 스프링 백엔드 개발에서 AssertJ와 같은 유창한 검증문 라이브러리를 사용하는 것은 선택이 아닌 표준적인 모범 사례로 여겨집니다.
