이전 장들에서 우리는 '무엇을' 테스트해야 하는가에 대해 깊이 탐구했다. 좋은 테스트는 구현 세부 사항이 아닌, 외부에서 식별 가능한 동작을 검증해야 한다는 결론을 내렸다. 이제 논의의 초점을 '어떻게'로 옮겨, 이러한 동작을 검증하는 구체적인 테스트 작성 스타일에 대해 알아볼 차례이다.

단위 테스트를 작성하는 방식은 크게 세 가지 스타일로 분류할 수 있다. 이 스타일들은 테스트의 검증(Assert) 단계에서 무엇을 확인하는지에 따라 구분된다. 어떤 스타일은 메서드의 반환 값을 직접 확인하고, 어떤 스타일은 시스템의 상태 변화를 확인하며, 또 다른 스타일은 외부 시스템과의 통신을 확인한다.

이 세 가지 스타일의 특징과 장단점을 이해하는 것은 주어진 문제에 가장 적합한 테스트 전략을 선택하는 데 매우 중요하다. 어떤 스타일은 매우 견고하고 유지보수하기 쉬운 반면, 어떤 스타일은 불가피하게 취약성을 내포하므로 신중하게 사용해야 한다. 이 장을 통해 각 스타일을 언제, 어떻게 사용해야 하는지에 대한 명확한 기준을 세우게 될 것이다.

## 6.1 단위 테스트의 세 가지 스타일

우리가 작성하는 거의 모든 단위 테스트는 다음의 세 가지 스타일 중 하나 또는 그 조합으로 설명할 수 있다. 이들을 명확히 이해하고 구분하는 것은 테스트의 의도를 명확히 하고, 더 나은 설계로 나아가는 첫걸음이다.

### 6.1.1 출력 기반 테스트 정의

**출력 기반 테스트(Output-based testing)**는 가장 순수하고 이상적인 형태의 테스트 스타일이다. 이 스타일은 테스트 대상 메서드가 반환하는 '출력(output)' 값을 검증하는 방식이다. 이 스타일로 테스트되는 메서드는 일반적으로 부수 효과(side effect)를 일으키지 않는다. 즉, 시스템의 다른 부분이나 자기 자신의 상태를 변경하지 않고, 오직 주어진 입력값을 바탕으로 어떤 연산을 수행한 뒤 그 결과를 반환할 뿐이다.

이러한 특성을 가진 메서드를 흔히 순수 함수(pure function)라고 부르며, 출력 기반 테스트는 바로 이 순수 함수를 테스트하는 데 최적화되어 있다.

가장 대표적인 예는 `Calculator` 클래스의 `add` 메서드이다.

```java
@Test
void add_should_return_sum_of_two_numbers() {
    // Arrange
    Calculator sut = new Calculator();

    // Act
    int result = sut.add(2, 3); // 메서드는 결과값을 반환한다.

    // Assert
    // 반환된 출력값을 직접 검증한다.
    assertThat(result).isEqualTo(5);
}
```

이 테스트는 SUT의 내부 상태나 외부와의 상호작용에는 전혀 관심이 없다. 오직 입력(2와 3)에 대해 올바른 출력(5)이 나오는지만을 확인한다. 이러한 테스트는 이해하기 매우 쉽고, 결정론적이며, 리팩터링 내성이 극도로 강하다. 메서드의 내부 구현이 어떻게 바뀌더라도 입력과 출력 간의 관계만 유지된다면 테스트는 항상 성공한다. 가능하다면 코드를 이처럼 부수 효과 없는 형태로 만들고 출력 기반 테스트를 작성하는 것이 가장 바람직하다.

### 6.1.2 상태 기반 스타일 정의

**상태 기반 테스트(State-based testing)**는 객체지향 프로그래밍에서 가장 흔하게 볼 수 있는 테스트 스타일이다. 이 스타일은 메서드 호출로 인해 발생하는 시스템의 '상태(state)' 변화를 검증한다. 테스트 대상 메서드는 값을 반환할 수도 있지만, 주로 아무것도 반환하지 않고(void) 내부 상태나 협력 객체의 상태를 변경하는 역할을 한다.

검증 단계에서는 이 상태 변화가 올바르게 일어났는지를 확인한다. 이는 SUT의 공개된 getter 메서드를 호출하여 변경된 속성 값을 확인하거나, 테스트 대역으로 사용된 협력 객체의 상태를 확인하는 방식으로 이루어진다.

5장에서 다룬 `User`의 이메일 변경 기능이 완벽한 예시이다.

```java
@Test
void changeEmail_should_change_user_state() {
    // Arrange
    User sut = new User(1L, "old@email.com");

    // Act
    sut.changeEmail("new@email.com"); // 메서드는 상태를 변경한다.

    // Assert
    // 변경된 '상태'를 검증한다.
    assertThat(sut.getEmail()).isEqualTo("new@email.com");
}
```

이 테스트는 `changeEmail` 메서드의 반환 값에는 관심이 없다. 대신 이 메서드를 실행한 '이후'에 `User` 객체의 이메일 속성이라는 상태가 기대하는 값으로 바뀌었는지를 검증한다.

상태 기반 테스트는 출력 기반 테스트 다음으로 선호되는 스타일이다. 이는 앞서 강조했던 '식별 가능한 동작'을 테스트하는 훌륭한 방법이기 때문이다. 내부 구현이 아닌, 최종적으로 나타나는 상태 변화라는 결과에 집중하므로 리팩터링 내성이 비교적 강하고 테스트의 의도도 명확하다.

### 6.1.3 통신 기반 스타일 정의

**통신 기반 테스트(Communication-based testing)**는 SUT가 협력 객체와 올바르게 '통신(communication)'하는지를 검증하는 스타일이다. 여기서 통신이란 SUT가 의존 객체의 메서드를 호출하는 행위를 의미한다. 이 스타일은 SUT의 반환 값이나 내부 상태 변화로는 검증할 수 없는 동작, 즉 외부 시스템으로 나가는 명령(Command)을 테스트할 때 필수적으로 사용된다.

통신 기반 테스트에서는 의존 객체를 목(Mock)으로 만들고, 테스트 실행 후 `verify` 구문을 사용하여 SUT가 이 목 객체의 특정 메서드를 올바른 인자와 함께 호출했는지를 확인한다.

5장에서 다룬 이메일 발송 기능이 바로 이 스타일에 해당한다.

```java
@Test
void placeOrder_should_send_confirmation_email() {
    // Arrange
    NotificationPort notificationPort = mock(NotificationPort.class); // 목 객체
    OrderService sut = new OrderService(notificationPort);

    // Act
    sut.placeOrder(new OrderRequest(/*...*/)); // 메서드는 외부 시스템과 통신한다.

    // Assert
    // 목 객체와의 '통신'을 검증한다.
    verify(notificationPort).sendOrderConfirmation(anyString(), any(OrderDetails.class));
}
```

이 테스트는 `placeOrder` 메서드가 어떤 값을 반환하는지, 또는 `OrderService`의 상태가 어떻게 변하는지에는 관심이 없다. 오직 `notificationPort`를 통해 확인 이메일을 보내라는 '명령'이 올바르게 전달되었는지에만 집중한다.

통신 기반 테스트는 매우 강력하지만 동시에 가장 위험한 스타일이다. 육각형 아키텍처의 경계를 넘나드는, 식별 가능한 동작을 검증하기 위해 올바르게 사용하면 매우 유용하다. 하지만 시스템 내부 통신, 즉 구현 세부 사항을 검증하는 데 잘못 사용하면 테스트 스위트 전체를 취약하게 만드는 주범이 된다. 따라서 이 스타일은 다른 두 스타일로 검증할 수 없는 경우에만 최후의 수단으로 신중하게 사용해야 한다.

## 6.2 단위 테스트 스타일 비교

세 가지 테스트 스타일을 정의했으니, 이제 이들을 체계적으로 비교해 볼 차례이다. 평가는 4장에서 소개한 좋은 테스트의 네 가지 핵심 요소, 즉 회귀 방지, 리팩터링 내성, 빠른 피드백, 유지보수성을 기준으로 삼을 것이다. 이 비교를 통해 우리는 어떤 스타일이 가장 바람직하며, 어떤 순서로 선호해야 하는지에 대한 명확한 지침을 얻게 될 것이다.

### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

**회귀 방지** 측면에서 보면, 세 스타일 간에 뚜렷한 차이가 나타난다. 출력 기반 테스트와 상태 기반 테스트는 SUT가 만들어낸 최종 결과를 직접 검증한다. 메서드의 반환 값이 정확한지, 또는 객체의 최종 상태가 올바른지를 확인하는 것은 실제 비즈니스 로직이 올바르게 동작했음을 가장 확실하게 증명하는 방법이다. 따라서 이 두 스타일은 회귀를 잡아내는 능력이 매우 뛰어나다.

반면, 통신 기반 테스트는 상대적으로 회귀 방지 능력이 약하다. 이 스타일은 SUT가 협력 객체에게 '올바른 메시지를 보냈는지'까지만 확인할 수 있을 뿐, 그 메시지를 받은 협력 객체가 실제로 올바르게 동작했는지, 그래서 시스템 전체에 원하는 결과가 나타났는지는 보장하지 못한다. 목 객체의 설정이 실제 객체의 동작과 다르거나, 실제 객체 자체에 버그가 있다면, 통신 기반 테스트는 성공하더라도 최종 기능은 실패하는 '거짓 음성'이 발생할 수 있다.

**피드백 속도** 측면에서는 세 스타일 간에 큰 차이가 없다. 세 스타일 모두 데이터베이스나 파일 시스템 같은 프로세스 외부 의존성을 사용하지 않는 순수한 단위 테스트로 작성되는 것을 전제로 한다. 따라서 모두 메모리 내에서 매우 빠르게 실행되며, 개발자에게 즉각적인 피드백을 제공할 수 있다. 그러므로 피드백 속도는 스타일을 선택하는 결정적인 기준이 되지는 못한다.

### 6.2.2 리팩터링 내성 지표로 스타일 비교하기

**리팩터링 내성**은 세 스타일의 가치를 가르는 가장 중요한 척도이다.

**출력 기반 테스트**는 이 지표에서 단연 최고 점수를 받는다. 이 스타일은 메서드의 공개된 시그니처, 즉 입력과 출력의 관계만을 검증하는 완벽한 블랙박스 테스트이다. 메서드 내부의 알고리즘이나 구조를 어떻게 리팩터링하더라도, 입력 대비 출력이 동일하게 유지되는 한 테스트는 절대 실패하지 않는다.

**상태 기반 테스트** 역시 매우 높은 리팩터링 내성을 가진다. 이 스타일 또한 최종적인 상태 변화라는 결과에 집중하기 때문에 내부적인 처리 과정의 변경에 영향을 받지 않는다. 다만, 상태를 확인하기 위해 사용하는 getter 메서드가 SUT의 공개 인터페이스의 일부라는 점에서 출력 기반 테스트보다는 미세하게 결합도가 높다고 볼 수 있지만, 실용적인 관점에서는 거의 동등하게 견고하다.

**통신 기반 테스트**는 리팩터링 내성 측면에서 가장 취약하다. 이 스타일은 정의상 SUT와 협력 객체 간의 내부 통신 패턴에 직접적으로 의존하는 화이트박스 테스트이다. 클래스 간의 책임이 재조정되거나 협력 방식이 바뀌는 모든 리팩터링 작업은 즉시 통신 기반 테스트의 실패로 이어진다. 이는 거짓 양성을 유발하고 코드 개선을 방해하는 가장 큰 원인이 된다.

### 6.2.3 유지 보수성 지표로 스타일 비교하기

**유지보수성**은 테스트 코드를 얼마나 쉽게 읽고, 이해하고, 수정할 수 있는지를 나타낸다. 이는 앞서 본 리팩터링 내성과도 깊은 관련이 있다.

**출력 기반 테스트**는 가장 유지보수하기 쉽다. 테스트 코드가 매우 간결하고 명확하다. 준비 단계에서 입력을 만들고, 실행 단계에서 함수를 호출하며, 검증 단계에서 반환된 결과를 확인하는 단순한 구조는 누구나 쉽게 이해할 수 있다.

**상태 기반 테스트** 역시 유지보수성이 높다. 테스트의 흐름이 직관적이며, 검증 대상인 최종 상태가 명확하게 드러나기 때문이다.

**통신 기반 테스트**는 세 스타일 중 가장 유지보수 비용이 높다. 목 객체를 설정하고 검증하는 코드는 종종 테스트를 길고 복잡하게 만든다. 특히 여러 개의 상호작용을 검증해야 할 경우 테스트의 의도를 파악하기 어려워진다. 게다가 리팩터링 시 가장 자주 실패하기 때문에, 지속적인 수정 노력이 필요하다는 점에서도 유지보수성이 가장 떨어진다.

### 6.2.4 스타일 비교하기: 결론

지금까지의 비교를 종합하면, 세 가지 단위 테스트 스타일 사이에는 명확한 선호도 순위가 존재한다.

1.  **최우선 선택: 출력 기반 테스트**
    가장 견고하고, 유지보수하기 쉬우며, 의도가 명확한 스타일이다. 이는 우리가 지향해야 할 이상적인 테스트의 모습이다.

2.  **차선책: 상태 기반 테스트**
    출력 기반으로 테스트하기 어려운 대부분의 객체지향 코드를 검증하는 실용적이고 훌륭한 방법이다. 리팩터링 내성과 회귀 방지 능력이 뛰어나다.

3.  **최후의 수단: 통신 기반 테스트**
    본질적으로 취약하며 유지보수 비용이 높다. 이 스타일은 앞의 두 스타일로 검증할 수 없는 경우, 즉 외부 시스템으로 나가는 명령을 검증하는 것과 같이 반드시 필요한 경우에만 제한적으로 사용해야 한다.

결론적으로 우리의 목표는 가능한 한 많은 코드를 부수 효과가 없는 형태로 작성하여 **출력 기반 테스트**로 검증하는 것이다. 이것이 어렵다면, 식별 가능한 최종 상태 변화를 **상태 기반 테스트**로 검증해야 한다. 그리고 **통신 기반 테스트**는 반드시 필요할 때만 사용하는 최후의 보루로 남겨두어야 한다. 이 원칙을 따르는 것이 개발자에게 실질적인 가치를 제공하는 견고하고 효율적인 테스트 스위트를 만드는 길이다.

## 6.3 함수형 아키텍처 이해

앞선 결론에서 우리는 출력 기반 테스트가 가장 이상적인 스타일이라고 말했다. 이는 가장 견고하고 유지보수하기 쉬우며, 테스트의 가치를 극대화하기 때문이다. 그렇다면 어떻게 해야 더 많은 코드를 출력 기반으로 테스트할 수 있을까? 그 해답은 **함수형 아키텍처(Functional Architecture)**라는 설계 방식에 있다.

함수형 아키텍처는 이름에서 알 수 있듯이 함수형 프로그래밍의 원칙과 아이디어를 소프트웨어 아키텍처 수준으로 확장한 개념이다. 이 아키텍처 스타일의 핵심 목표는 코드베이스에서 부수 효과(side effect)를 일으키는 부분을 최소화하고, 비즈니스 로직의 대부분을 순수 함수(pure function)로 구성하는 것이다. 이렇게 하면 코드의 대부분을 가장 이상적인 테스트 스타일인 출력 기반 테스트로 검증할 수 있게 된다.

### 6.3.1 함수형 프로그래밍이란?

함수형 아키텍처를 이해하기 위해 먼저 함수형 프로그래밍의 핵심 개념인 **불변성(Immutability)**과 **부수 효과(Side Effect)**를 알아야 한다.

**불변성**이란, 한 번 생성된 데이터는 그 상태를 변경할 수 없다는 원칙이다. 만약 데이터의 수정이 필요하다면, 기존 데이터를 바꾸는 대신 변경 사항이 적용된 새로운 데이터를 생성하여 반환해야 한다. 자바의 `String` 클래스가 대표적인 예이다. `String` 객체의 메서드를 호출하면 원본 문자열이 바뀌는 것이 아니라, 항상 새로운 `String` 객체가 생성되어 반환된다. 이러한 불변성은 프로그램의 상태 변화를 예측 가능하게 만들어 복잡도를 크게 낮춰준다.

**부수 효과**란, 함수가 결과값을 반환하는 것 외에 외부 세계에 어떤 영향을 미치는 모든 행위를 말한다. 대표적인 부수 효과는 다음과 같다.

* 객체나 변수의 상태를 변경하는 행위
* 데이터베이스에 데이터를 쓰거나 읽는 행위
* 파일 시스템에 파일을 쓰는 행위
* 콘솔에 로그를 출력하는 행위
* 외부 API를 호출하는 행위

함수형 프로그래밍은 이러한 부수 효과를 최대한 억제하고 격리하는 것을 목표로 한다. 부수 효과가 없는 함수, 즉 동일한 입력에 대해 항상 동일한 출력을 반환하고 외부 상태를 변경하지 않는 함수를 **순수 함수(Pure Function)**라고 부른다. `int add(int a, int b) { return a + b; }` 와 같은 함수가 완벽한 순수 함수이다. 순수 함수는 예측 가능하고 테스트하기 매우 쉽다는 엄청난 장점을 가진다.

### 6.3.2 함수형 아키텍처란?

함수형 아키텍처는 이러한 함수형 프로그래밍의 원칙을 시스템 전체의 설계에 적용한 것이다. 이 아키텍처는 코드베이스를 크게 두 부분으로 나눈다.

1. **핵심 비즈니스 로직 (순수 함수의 영역)**: 시스템의 모든 중요한 결정과 계산은 이 영역에서 이루어진다. 이 영역의 코드는 최대한 순수 함수로 구성되어야 하며, 부수 효과를 절대 일으켜서는 안 된다. 이 영역의 함수들은 오직 입력값을 받아 연산을 수행하고 그 결과(출력값)를 반환하는 역할만 한다.
2. **부수 효과를 다루는 래퍼(Wrapper) 계층 (비순수 함수의 영역)**: 핵심 비즈니스 로직에서 나온 결정(출력값)을 실제 세계에 반영하는 역할은 이 래퍼 계층이 담당한다. 예를 들어, 핵심 로직이 '사용자를 데이터베이스에 저장하라'는 결정을 내리면, 이 계층이 실제로 데이터베이스에 접속하여 `INSERT` 쿼리를 실행한다. 외부 세계(UI, 데이터베이스 등)로부터 입력을 받아 핵심 로직에 전달하는 역할도 이 계층이 맡는다. 즉, 시스템의 모든 부수 효과는 이 얇은 래퍼 계층에 격리된다.

이러한 분리를 통해 우리는 코드베이스의 90% 이상을 차지하는 복잡하고 중요한 비즈니스 로직을 테스트하기 매우 쉬운 순수 함수의 형태로 만들 수 있다. 그리고 나머지 10%의 부수 효과를 다루는 코드는 상대적으로 단순하므로, 통신 기반 테스트나 통합 테스트를 통해 최소한으로 검증하면 된다. 이것이 바로 함수형 아키텍처가 테스트 용이성을 극대화하는 원리이다.

### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교

함수형 아키텍처는 5장에서 살펴본 육각형 아키텍처와 매우 유사하며, 사실상 육각형 아키텍처의 철학을 더욱 함수형 스타일로 발전시킨 형태라고 볼 수 있다.

* **공통점**: 두 아키텍처 모두 비즈니스 로직(도메인)을 외부의 기술적인 세부 사항(인프라)으로부터 격리하는 것을 최우선 목표로 한다. 육각형 아키텍처의 '육각형 내부'는 함수형 아키텍처의 '핵심 비즈니스 로직' 영역에 해당하고, '어댑터'는 '부수 효과를 다루는 래퍼 계층'에 해당한다.
* **차이점**: 가장 큰 차이는 부수 효과를 다루는 방식에 있다. 육각형 아키텍처는 객체지향적인 접근 방식을 취하며, 비즈니스 로직과 부수 효과를 포트(인터페이스)를 통해 분리한다. 하지만 육각형 내부의 도메인 객체들 자체는 상태를 가질 수 있으며, 메서드 호출을 통해 자신의 상태를 변경하는(부수 효과를 일으키는) 것이 허용된다. 즉, 상태 기반 테스트의 대상이 되는 코드가 많다.

    반면, 함수형 아키텍처는 여기서 한 걸음 더 나아간다. 이 아키텍처는 비즈니스 로직 자체를 불변 데이터 구조와 순수 함수로 구성하여, 로직 내에서의 부수 효과 자체를 원천적으로 제거하려고 시도한다. 그 결과, 비즈니스 로직의 대부분이 상태 기반 테스트가 아닌, 가장 이상적인 형태인 출력 기반 테스트의 대상이 된다.

결론적으로 함수형 아키텍처는 테스트 관점에서 육각형 아키텍처보다 한 단계 더 진화한 형태로, 테스트 용이성을 최고 수준으로 끌어올릴 수 있는 강력한 설계 패러다임이다.

## 6.4 함수형 아키텍처와 출력 기반 테스트로 전환

이론은 충분하다. 이제 실제 코드를 통해 함수형 아키텍처로 전환하는 것이 어떻게 테스트의 스타일을 바꾸고 그 가치를 높이는지 직접 확인해 보자. 우리는 부수 효과가 가득한 일반적인 객체지향 코드를 리팩터링하여, 비즈니스 로직을 순수 함수로 분리하고 이를 가장 이상적인 방식인 출력 기반으로 테스트하는 전 과정을 단계별로 살펴볼 것이다.

이 예제를 통해 우리는 함수형 아키텍처가 단지 학문적인 개념이 아니라, 테스트하기 쉽고 유지보수하기 용이한 코드를 만드는 매우 실용적인 도구임을 깨닫게 될 것이다.

### 6.4.1 감사 시스템 소개

우리가 다룰 예제는 간단한 파일 기반 감사 시스템이다. 이 시스템의 요구사항은 다음과 같다.

1. 시스템에서 발생하는 특정 이벤트(예: 파일 접근)를 감사 로그로 기록해야 한다.
2. 로그는 지정된 디렉터리에 `audit_1.txt`, `audit_2.txt` 와 같은 형식의 파일로 저장된다.
3. 하나의 감사 파일에는 최대 N개의 로그만 기록할 수 있다.
4. 만약 현재 파일이 꽉 차면, 시스템은 다음 순번의 새 파일을 자동으로 생성하여 로그를 기록해야 한다.

이 요구사항을 일반적인 객체지향 스타일로 구현한 `AuditManager` 클래스는 다음과 같을 것이다. 이 코드는 상태(현재 디렉터리)를 가지며, 파일 시스템이라는 외부 세계와 직접 상호작용하는 부수 효과를 포함하고 있다.

**초기 구현: 부수 효과가 가득한 클래스**

```java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class AuditManager {
    private final int maxEntriesPerFile;
    private final String directoryName;

    public AuditManager(int maxEntriesPerFile, String directoryName) {
        this.maxEntriesPerFile = maxEntriesPerFile;
        this.directoryName = directoryName;
    }

    public void addRecord(String visitorName, LocalDateTime timeOfVisit) throws IOException {
        File directory = new File(directoryName);
        File[] files = directory.listFiles();
        Arrays.sort(files); // 파일 이름 순으로 정렬

        String newRecord = visitorName + ";" + timeOfVisit.toString();

        if (files.length == 0) {
            // 파일이 하나도 없으면 새 파일을 만든다.
            Path newFilePath = Paths.get(directoryName, "audit_1.txt");
            Files.write(newFilePath, Collections.singletonList(newRecord));
            return;
        }

        File lastFile = files[files.length - 1];
        List<String> lines = Files.readAllLines(lastFile.toPath());

        if (lines.size() < maxEntriesPerFile) {
            // 마지막 파일에 여유 공간이 있으면 거기에 추가한다.
            Files.write(lastFile.toPath(), Collections.singletonList(newRecord), StandardOpenOption.APPEND);
        } else {
            // 마지막 파일이 꽉 찼으면 새 파일을 만든다.
            int newIndex = files.length + 1;
            Path newFilePath = Paths.get(directoryName, "audit_" + newIndex + ".txt");
            Files.write(newFilePath, Collections.singletonList(newRecord));
        }
    }
}
```

이 코드는 어떻게 테스트해야 할까? `addRecord` 메서드는 실제 파일 시스템에 파일을 읽고 쓰는 동작을 포함하고 있다. 단위 테스트에서 실제 파일 시스템에 의존하는 것은 테스트를 느리고 불안정하게 만들며, 테스트 실행 환경을 복잡하게 만든다. 이는 우리가 반드시 피해야 할 상황이다.

### 6.4.2 테스트를 파일 시스템에서 분리하기 위한 목 사용

대부분의 개발자는 이러한 문제를 해결하기 위해 의존성 역전 원칙(DIP)을 적용하여 파일 시스템과의 상호작용을 추상화하고, 테스트에서는 목(Mock) 객체를 사용할 것이다. 먼저 파일 시스템에 대한 인터페이스를 정의한다.

**파일 시스템 인터페이스**
```java
public interface FileSystemGateway {
    String[] getFiles(String directoryName);
    void writeAllText(String filePath, String content);
    void appendAllText(String filePath, String content);
    List<String> readAllLines(String filePath);
}
```

그리고 `AuditManager`가 이 인터페이스에 의존하도록 수정한다. 이제 테스트에서는 `FileSystemGateway`를 목으로 만들어 `AuditManager`와의 통신을 검증할 수 있다.

**통신 기반 테스트 예시**
```java
@Test
void addRecord_should_write_to_new_file_when_current_is_full() {
    // Arrange
    String visitorName = "Alice";
    LocalDateTime timeOfVisit = LocalDateTime.now();
    FileSystemGateway gateway = mock(FileSystemGateway.class);
    AuditManager sut = new AuditManager(1, "audits", gateway); // 최대 1개 항목

    // 현재 파일이 꽉 찬 상황을 스텁으로 흉내 낸다.
    when(gateway.getFiles("audits")).thenReturn(new String[]{"audit_1.txt"});
    when(gateway.readAllLines("audits/audit_1.txt"))
            .thenReturn(Collections.singletonList("Bob;2025-01-01T10:00:00"));

    // Act
    sut.addRecord(visitorName, timeOfVisit);

    // Assert
    // 새 파일에 올바른 내용을 쓰라는 '통신'이 일어났는지 검증한다.
    verify(gateway).writeAllText(
            "audits/audit_2.txt",
            "Alice;" + timeOfVisit.toString()
    );
}
```

이 테스트는 동작한다. 파일 시스템과의 의존성을 성공적으로 분리했으며, `AuditManager`가 특정 시나리오에서 올바르게 동작하는지를 검증할 수 있다. 하지만 이 테스트는 우리가 피하고자 했던 **통신 기반 테스트**의 전형적인 예이다.

이 테스트의 문제점은 명확하다.

* **취약함**: `AuditManager`가 파일 시스템과 상호작용하는 방식을 조금이라도 바꾸면(예: `writeAllText` 대신 다른 메서드를 사용하도록 리팩터링하면) 테스트는 즉시 실패한다.
* **복잡함**: 목 객체의 동작을 미리 설정(`when`)하고, 사후에 검증(`verify`)하는 코드는 테스트의 복잡도를 높이고 가독성을 떨어뜨린다.
* **구현 세부 사항 노출**: 이 테스트는 `AuditManager`가 '어떻게' 파일을 처리하는지에 대한 내부 로직을 낱낱이 알고 있어야만 작성할 수 있다.

이것이 바로 전통적인 객체지향 접근법과 목킹이 가진 한계이다. 이제 우리는 함수형 아키텍처를 적용하여 이 문제를 근본적으로 해결해 볼 것이다.

### 6.4.3 함수형 아키텍처로 리팩터링하기

함수형 아키텍처의 핵심은 **비즈니스 결정**과 **부수 효과**를 분리하는 것이다. 현재 `AuditManager`의 `addRecord` 메서드는 이 두 가지를 한 번에 처리하고 있다.

* **비즈니스 결정**: "새로운 로그를 어떤 파일에 어떤 내용으로 기록해야 하는가?"라는 결정. 여기에는 파일 목록을 보고, 마지막 파일이 꽉 찼는지 확인하고, 새 파일의 이름을 만드는 등의 순수한 비즈니스 규칙이 포함된다.
* **부수 효과**: 위 결정에 따라 실제로 파일 시스템에 파일을 쓰거나 읽는 행위.

우리의 목표는 이 비즈니스 결정 부분을 **순수 함수**로 추출하는 것이다. 이 함수는 외부 세계에 대한 어떤 정보도 직접 접근해서는 안 된다. 대신 필요한 모든 정보를 매개변수로 받아야 하며, 자신의 결정(어떤 파일을 어떻게 변경해야 하는지)을 값(Value)으로 반환해야 한다.

먼저, 파일 업데이트에 대한 결정을 표현하는 간단한 값 객체 `FileUpdate`를 정의하자. 이 객체는 불변(immutable)이어야 한다.

**값 객체: FileUpdate**

```java
public class FileUpdate {
    public final String fileName;
    public final String content;

    public FileUpdate(String fileName, String content) {
        this.fileName = fileName;
        this.content = content;
    }

    // equals()와 hashCode() 구현...
}
```

이제 핵심 로직을 담당할 새로운 클래스 `AuditManagerV2`를 만들고, 비즈니스 결정을 내리는 순수 함수 `handle`을 작성한다. 이 함수는 현재 디렉터리의 파일 정보(`FileContent[]`)와 새로운 로그 정보를 입력으로 받아, 어떤 파일을 업데이트해야 하는지에 대한 정보(`FileUpdate`)를 출력으로 반환한다.

**리팩터링된 AuditManagerV2와 순수 함수 handle**

```java
// 현재 파일 상태를 나타내는 불변 값 객체
public class FileContent {
    public final String fileName;
    public final String[] lines;
    // ... 생성자, equals, hashCode ...
}

public class AuditManagerV2 {
    private final int maxEntriesPerFile;

    public AuditManagerV2(int maxEntriesPerFile) {
        this.maxEntriesPerFile = maxEntriesPerFile;
    }

    // 핵심 비즈니스 로직을 담은 순수 함수
    public FileUpdate handle(FileContent[] files, String visitorName, LocalDateTime timeOfVisit) {
        Arrays.sort(files, Comparator.comparing(f -> f.fileName));

        String newRecord = visitorName + ";" + timeOfVisit.toString();

        if (files.length == 0) {
            return new FileUpdate("audit_1.txt", newRecord);
        }

        FileContent lastFile = files[files.length - 1];

        if (lastFile.lines.length < maxEntriesPerFile) {
            return new FileUpdate(lastFile.fileName, newRecord);
        } else {
            int newIndex = files.length + 1;
            return new FileUpdate("audit_" + newIndex + ".txt", newRecord);
        }
    }
}
```

`handle` 메서드를 보라. 이 메서드는 더 이상 `java.io`나 `java.nio` 패키지에 의존하지 않는다. 파일 시스템을 직접 건드리는 대신, `FileContent`라는 단순한 데이터 구조를 입력받아 `FileUpdate`라는 또 다른 데이터 구조를 반환할 뿐이다. 이것이 바로 부수 효과가 완전히 제거된 **순수 함수**이다.

이제 이 순수 함수를 어떻게 테스트할 수 있을까? 목도, 스텁도, `verify`도 필요 없다. 오직 입력과 그에 따른 출력을 비교하는 가장 이상적인 **출력 기반 테스트**만 있으면 된다.

**출력 기반 테스트 예시**

```java
@Test
void handle_should_return_update_for_new_file_when_current_is_full() {
    // Arrange
    AuditManagerV2 sut = new AuditManagerV2(1); // 최대 1개 항목
    String visitorName = "Alice";
    LocalDateTime timeOfVisit = LocalDateTime.now();

    // 현재 파일이 꽉 찬 상황을 단순한 데이터로 준비한다.
    FileContent[] files = { new FileContent("audit_1.txt", new String[]{"Bob;2025-01-01T10:00:00"}) };
    
    // 기대하는 출력값을 미리 정의한다.
    FileUpdate expected = new FileUpdate("audit_2.txt", "Alice;" + timeOfVisit.toString());

    // Act
    // 순수 함수를 호출하여 결과를 받는다.
    FileUpdate result = sut.handle(files, visitorName, timeOfVisit);

    // Assert
    // 반환된 출력값이 기대값과 같은지 직접 비교한다.
    assertThat(result).isEqualTo(expected);
}
```

이전의 통신 기반 테스트와 비교해 보라. 이 테스트는 훨씬 더 간결하고, 명확하며, 견고하다.

* **견고함**: `AuditManagerV2` 내부의 정렬 알고리즘이나 로직 처리 방식을 어떻게 리팩터링하든, 입력 대비 출력의 비즈니스 규칙만 동일하다면 이 테스트는 절대 실패하지 않는다.
* **단순함**: 복잡한 목 설정(`when`)이나 검증(`verify`) 코드가 전혀 없다. 준비(Arrange) 단계는 간단한 데이터 생성이 전부이고, 검증(Assert) 단계는 두 객체가 같은지 비교하는 것이 전부이다.
* **구현 독립성**: 테스트는 `handle` 메서드가 '무엇을' 하는지에만 관심이 있을 뿐, '어떻게' 하는지에는 전혀 관심이 없다.

### 6.4.4 예상되는 추가 개발

이제 우리는 순수한 비즈니스 로직을 완벽하게 테스트했다. 남은 일은 무엇일까? 바로 이 순수 함수가 반환한 `FileUpdate`라는 '결정'을 실제 파일 시스템에 반영하는 **부수 효과를 일으키는 래퍼(wrapper) 코드**를 작성하는 것이다.

이 래퍼 코드는 육각형 아키텍처의 어댑터와 같은 역할을 하며, 매우 단순할 것이다.

**부수 효과를 처리하는 Persister 클래스**

```java
public class Persister {
    private final FileSystemGateway gateway; // 실제 파일 시스템에 접근

    public Persister(FileSystemGateway gateway) {
        this.gateway = gateway;
    }

    public void applyUpdate(String directoryName, FileUpdate update) {
        String filePath = directoryName + "/" + update.fileName;
        // 파일이 이미 존재하는지 확인하는 로직 추가...
        // 존재하면 append, 존재하지 않으면 write
        if (/* 파일이 존재하면 */) {
            gateway.appendAllText(filePath, update.content);
        } else {
            gateway.writeAllText(filePath, update.content);
        }
    }
}
```

이제 전체 애플리케이션은 이 두 조각, 즉 `AuditManagerV2`와 `Persister`를 조합하여 동작한다. 컨트롤러나 메인 애플리케이션은 먼저 `Persister`를 통해 현재 파일 상태를 읽어와 `FileContent[]` 배열을 만들고, 이 데이터를 `AuditManagerV2.handle()`에 전달하여 `FileUpdate` 결정을 받은 뒤, 다시 이 `FileUpdate`를 `Persister.applyUpdate()`에 전달하여 실제 파일 시스템에 쓰는 흐름으로 구성될 것이다.

이 `Persister` 클래스는 어떻게 테스트해야 할까? 이 클래스는 매우 단순하며 로직이 거의 없다. 간단한 통합 테스트를 통해 실제 파일 시스템(또는 인메모리 파일 시스템)과 올바르게 상호작용하는지만 확인하면 충분하다. 복잡하고 중요한 비즈니스 로직은 이미 100% 신뢰할 수 있는 출력 기반 단위 테스트로 검증되었기 때문에, 이 부분에 대한 테스트 부담은 거의 없다.

이것이 바로 함수형 아키텍처의 힘이다. 복잡성은 순수 함수 영역으로 옮겨 철저히 테스트하고, 부수 효과는 단순한 래퍼 계층으로 격리하여 테스트의 부담을 최소화하는 것. 이 접근 방식을 통해 우리는 테스트하기 쉽고, 이해하기 쉬우며, 변화에 유연하게 대처할 수 있는 소프트웨어를 만들 수 있다.

## 6.5 함수형 아키텍처의 단점 이해하기

앞선 절에서 우리는 함수형 아키텍처가 어떻게 테스트의 품질을 극적으로 향상시키는지를 보았다. 하지만 세상의 모든 엔지니어링 결정에는 트레이드오프가 따르듯이, 함수형 아키텍처 역시 만병통치약은 아니다. 이 접근법을 채택하기 전에 그것이 수반하는 비용과 잠재적인 단점을 이해하는 것은 매우 중요하다.

### 6.5.1 함수형 아키텍처 적용 가능성

함수형 아키텍처가 주는 가장 큰 이점은 **복잡한 비즈니스 로직의 테스트 용이성을 확보**하는 것이다. 따라서 이 패턴의 가치는 테스트 대상이 되는 로직의 복잡도에 정비례한다. 수많은 비즈니스 규칙과 조건문, 다양한 엣지 케이스를 포함하는 시스템의 핵심 도메인 로직에 이 아키텍처를 적용하면, 테스트와 유지보수에 드는 비용을 크게 절감하는 엄청난 효과를 볼 수 있다.

하지만 반대로, 비즈니스 로직이 거의 없는 단순한 코드에 이 패턴을 적용하는 것은 과도한 설계(over-engineering)일 수 있다. 예를 들어, 단순히 데이터베이스에서 데이터를 조회하여 DTO로 변환해 반환하는 간단한 CRUD 컨트롤러나 서비스가 있다고 가정해 보자. 이러한 코드에는 복잡한 '결정'이 거의 없다. 여기에 굳이 결정과 부수 효과를 분리하기 위해 여러 클래스와 데이터 객체를 도입하는 것은 코드의 양만 늘리고 별다른 이점을 주지 못할 수 있다.

따라서 함수형 아키텍처는 모든 곳에 적용해야 하는 규칙이 아니라, 복잡성을 다루기 위한 강력한 도구로 이해해야 한다. 코드베이스에서 가장 복잡하고 중요한 핵심 비즈니스 로직을 식별하고, 그 부분에 집중적으로 이 패턴을 적용하는 것이 현명한 전략이다.

### 6.5.2 성능 단점

함수형 아키텍처, 특히 불변성(immutability)을 강조하는 접근법은 특정 시나리오에서 성능 저하를 유발할 수 있다.

`AuditManagerV2` 예제로 돌아가 보자. 우리의 순수 함수 `handle`은 현재 디렉터리의 모든 파일 내용을 `FileContent[]` 배열로 전달받았다. 만약 감사 파일이 수천 개에 달하고 각 파일의 크기가 매우 크다면, 이 모든 파일의 내용을 한 번에 메모리에 올리는 것은 상당한 메모리 사용량 증가와 성능 저하를 초래할 수 있다. 반면, 원래의 명령형 스타일 코드는 오직 마지막 파일 하나만 읽으면 되었을 수도 있다.

또한, 불변 데이터 구조를 사용하는 것은 필연적으로 더 많은 객체 생성을 유발한다. 상태를 변경하는 대신 항상 새로운 객체를 생성하여 반환하기 때문이다. 이는 가비지 컬렉터(Garbage Collector)에 더 많은 부담을 주게 되며, 극도로 높은 성능을 요구하는 시스템에서는 문제가 될 수 있다.

하지만 이러한 성능 단점은 대부분의 일반적인 비즈니스 애플리케이션에서는 크게 문제 되지 않는 경우가 많다. 하드웨어의 성능이 충분히 발전했고, JVM의 가비지 컬렉터 또한 매우 효율적으로 최적화되었기 때문이다. 그럼에도 불구하고, 대용량 데이터를 다루거나 실시간 처리가 매우 중요한 시스템을 개발하고 있다면, 함수형 아키텍처를 도입하기 전에 반드시 성능 테스트를 통해 잠재적인 병목 지점을 확인하는 과정이 필요하다.

### 6.5.3 코드베이스 크기 증가

함수형 아키텍처를 적용하면 코드의 전체적인 양이 늘어나는 경향이 있다. `AuditManager` 예제에서 우리는 원래 하나의 클래스였던 로직을 `AuditManagerV2`, `Persister`, `FileContent`, `FileUpdate` 등 여러 개의 클래스와 데이터 구조로 분리했다.

이렇게 코드의 양이 늘어나는 것은 표면적으로는 단점처럼 보일 수 있다. 하지만 여기서 중요한 것은 코드의 양이 아니라 **질**이다. 함수형 아키텍처를 통해 늘어난 코드는 각자 하나의 명확한 책임만을 가지며, 서로 느슨하게 결합되어 있다. 즉, 코드의 **응집도(cohesion)는 높아지고 결합도(coupling)는 낮아진다.**

이러한 특성은 장기적인 유지보수 관점에서 엄청난 이점을 가져다준다. 코드를 이해하고 수정하기가 훨씬 쉬워지며, 특정 부분의 변경이 다른 부분에 미치는 영향을 최소화할 수 있다. 초기에 조금 더 많은 코드를 작성하는 비용을 지불하는 대신, 미래에 발생할 수 있는 훨씬 더 큰 유지보수 비용을 절감하는 현명한 투자로 볼 수 있다. 그럼에도 불구하고, 팀이 패턴에 익숙하지 않거나 프로젝트 일정이 매우 촉박한 상황에서는 이러한 초기 작성 비용이 부담으로 작용할 수는 있다.
