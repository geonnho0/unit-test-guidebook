5장에서 우리는 목(Mock)이 테스트의 리팩터링 내성을 해치는 주된 원인이 될 수 있음을 경고했다. 목은 테스트를 코드의 내부 구현에 결합시켜, 실제 버그가 없음에도 리팩터링만으로 테스트가 실패하는 '깨지기 쉬운 테스트'를 만드는 주범이 될 수 있기 때문이다.

하지만 8장에서 통합 테스트를 다루며 우리는 목의 또 다른 얼굴을 보았다. 제어할 수 없는 외부 의존성(비관리 의존성)과의 통신을 검증하는 데 있어 목은 매우 효과적이고 필수적인 도구였다. 이처럼 목은 양날의 검과 같다. 잘못 사용하면 프로젝트에 해를 끼치지만, 올바르게 사용하면 단위 테스트와 통합 테스트 모두에서 중요한 역할을 수행할 수 있다.

이 장의 목표는 이 양날의 검을 안전하고 효과적으로 다루는 구체적인 기술을 연마하는 것이다. 우리는 '시스템의 경계에서만 목을 사용하라'는 황금률을 바탕으로, 목의 가치를 극대화하고 잠재적인 위험을 최소화하는 여러 모범 사례들을 깊이 있게 탐구할 것이다.

## 9.1 목의 가치를 극대화하기

목의 가치를 극대화한다는 것은 최소한의 테스트 취약성을 대가로 최대한의 회귀 방지 능력을 얻어내는 것을 의미한다. 즉, 꼭 필요한 상호작용만을, 가장 효과적인 방법으로 검증해야 한다. 이는 테스트의 대상을 신중하게 선택하고, 때로는 목보다 더 나은 테스트 대역을 사용하는 지혜를 필요로 한다.

### 9.1.1 시스템 끝에서 상호 작용 검증하기

'시스템의 경계에서 목을 사용하라'는 원칙을 더 구체화해 보자. 이는 SUT(System Under Test)가 최종적으로 **프로세스 외부의 비관리 의존성으로 나가는 마지막 호출**만을 검증해야 한다는 의미이다.

예를 들어, `OrderService`가 주문 완료 후 이메일을 보내는 시나리오를 생각해보자. `OrderService`는 먼저 `EmailFormatter`를 사용해 이메일 본문을 HTML로 만든 다음, `EmailGateway` 인터페이스를 통해 이메일을 발송할 수 있다.

```java
public class OrderService {
    private final EmailFormatter emailFormatter;
    private final EmailGateway emailGateway;

    // ... 생성자 ...

    public void completeOrder(Order order) {
        String emailBody = emailFormatter.formatOrderConfirmation(order);
        emailGateway.send(order.getCustomerEmail(), "주문 완료", emailBody);
    }
}
```

이 코드를 테스트할 때, `EmailFormatter`와 `EmailGateway`를 모두 목으로 만들고 각각의 호출을 검증하는 것은 잘못된 접근이다.

**나쁜 예: 내부 통신까지 검증하는 경우**

```java
@Test
void completeOrder_should_format_and_send_email() {
    // Arrange
    EmailFormatter formatter = mock(EmailFormatter.class); // 내부 협력 객체를 목으로 처리 (나쁨!)
    EmailGateway gateway = mock(EmailGateway.class);       // 외부 시스템 경계를 목으로 처리 (좋음)
    OrderService sut = new OrderService(formatter, gateway);
    Order order = new Order(/*...*/);

    when(formatter.formatOrderConfirmation(order)).thenReturn("<html>...</html>");

    // Act
    sut.completeOrder(order);

    // Assert
    verify(formatter).formatOrderConfirmation(order); // 내부 구현 검증 (나쁨!)
    verify(gateway).send(anyString(), anyString(), anyString()); // 최종 출력 검증 (좋음)
}
```

`EmailFormatter`와의 상호작용을 검증하는 것은 `OrderService`의 내부 구현에 테스트를 결합시킨다. 나중에 이메일 포맷팅 로직을 `OrderService` 내부의 비공개 메서드로 리팩터링하면 이 테스트는 즉시 실패한다. `EmailFormatter`는 시스템의 끝이 아니라 내부에 있는 협력 객체일 뿐이다.

올바른 방법은 `OrderService`를 하나의 블랙박스로 보고, 최종적으로 시스템 경계를 넘어가는 `EmailGateway.send()` 호출 하나만을 검증하는 것이다.

**좋은 예: 시스템의 끝(경계)에서만 검증하는 경우**

```java
@Test
void completeOrder_should_send_email() {
    // Arrange
    EmailGateway gateway = mock(EmailGateway.class); // 시스템 경계만 목으로 처리
    // EmailFormatter는 실제 객체를 사용한다.
    EmailFormatter formatter = new EmailFormatter(); 
    OrderService sut = new OrderService(formatter, gateway);
    Order order = new Order(/*...*/);
    String expectedBody = formatter.formatOrderConfirmation(order); // 기대값을 미리 계산

    // Act
    sut.completeOrder(order);

    // Assert
    // 오직 시스템의 최종적인 출력(이메일 발송)만을 검증한다.
    verify(gateway).send(order.getCustomerEmail(), "주문 완료", expectedBody);
}
```

이 테스트는 `OrderService`가 어떻게 이메일 본문을 만드는지에는 관심이 없다. 오직 '최종적으로 올바른 내용의 이메일이 발송되었는가'라는 식별 가능한 동작에만 집중한다. 이렇게 시스템의 가장 끝단에서만 상호작용을 검증하는 것이 목의 가치를 극대화하고 취약성을 최소화하는 핵심 원칙이다.

### 9.1.2 목을 스파이로 대체하기

때로는 목(Mock)보다 **스파이(Spy)**가 더 나은 테스트 대역이 될 때가 있다. 목과 스파이는 둘 다 테스트 대역이지만, 작동 방식에 근본적인 차이가 있다.

* **목 (Mock)**: 껍데기만 있는 완전한 가짜 객체다. 모든 메서드는 기본적으로 아무 동작도 하지 않거나 기본값(0, null, false 등)을 반환한다. 따라서 테스트에서 사용될 모든 메서드의 동작을 `when(...).thenReturn(...)` 구문을 통해 일일이 정의해주어야 한다.
* **스파이 (Spy)**: 실제 객체를 감싸는 래퍼(wrapper) 객체다. 스파이 객체의 메서드를 호출하면, 기본적으로는 실제 객체의 원본 메서드가 그대로 호출된다. 하지만 목처럼 특정 메서드의 동작만을 선택적으로 가짜로 만들거나(`doReturn(...).when(spy).methodToStub()`), 메서드 호출 여부를 검증(`verify`)할 수 있다.

스파이는 실제 객체의 동작을 기반으로 하면서 일부만 변경하고 싶을 때 유용하다. 예를 들어, 우리가 테스트하려는 클래스가 외부 의존성을 가지면서 동시에 복잡한 내부 상태나 계산 로직을 포함하고 있다고 가정해 보자. 이 클래스를 목으로 만들면, 테스트에 필요한 모든 내부 상태와 계산 로직을 `when` 구문으로 흉내 내야 하므로 테스트가 매우 복잡해질 수 있다.

이럴 때 스파이를 사용하면, 복잡한 내부 로직은 실제 객체가 그대로 처리하도록 두고, 외부 의존성과 통신하는 단 하나의 메서드만 가짜로 만들어 테스트의 복잡도를 낮출 수 있다.

**스파이 사용 예시**

```java
public class ComplexReportGenerator {
    public String generate(Data data) {
        // 1. 매우 복잡한 데이터 분석 및 계산 로직
        AnalyzedData analyzed = analyze(data);
        // 2. 외부 스토리지에 결과 저장 (테스트하고 싶지 않은 부분)
        saveToCloud(analyzed);
        // 3. 최종 리포트 문자열 생성
        return formatReport(analyzed);
    }
    
    // 이 메서드는 실제 네트워크 통신을 유발한다.
    protected void saveToCloud(AnalyzedData data) {
        // ... 실제 클라우드 스토리지 API 호출 ...
    }
    
    private AnalyzedData analyze(Data data) { /* ... 복잡한 로직 ... */ }
    private String formatReport(AnalyzedData data) { /* ... 복잡한 로직 ... */ }
}

@Test
void generate_should_create_correct_report() {
    // Arrange
    Data testData = new Data(/* ... */);
    // 실제 객체를 기반으로 스파이를 생성한다.
    ComplexReportGenerator realGenerator = new ComplexReportGenerator();
    ComplexReportGenerator sut = spy(realGenerator);

    // saveToCloud 메서드만 아무것도 하지 않도록 가짜로 만든다.
    doNothing().when(sut).saveToCloud(any(AnalyzedData.class));

    // Act
    String report = sut.generate(testData);

    // Assert
    // 복잡한 분석 및 포맷팅 로직은 실제 객체가 수행했으므로,
    // 그 최종 결과인 리포트의 내용만 검증하면 된다.
    assertThat(report).contains("Expected Report Content");

    // 원한다면 외부 호출이 시도되었는지 검증할 수도 있다.
    verify(sut).saveToCloud(any(AnalyzedData.class));
}
```

이처럼 스파이는 실제 객체의 복잡한 로직을 그대로 활용하면서, 외부와의 통신 지점만 격리하여 테스트할 수 있게 해주는 유용한 도구다. 하지만 스파이는 목보다 더 깊숙이 실제 클래스의 내부 구조에 관여하므로, 남용하면 테스트가 구현 세부 사항에 더 강하게 결합될 수 있다는 점을 항상 경계해야 한다. 꼭 필요한 경우에 신중하게 사용하는 것이 좋다.

### 9.1.3 IDomainLogger는 어떤가?

8.6절에서 우리는 로깅 기능은 일반적으로 테스트의 대상이 아니지만, 법적 요구나 비즈니스적으로 매우 중요한 감사 로그(Audit Log)의 경우는 예외라고 이야기했다. 이러한 감사 로그를 남기는 로거를 `IDomainLogger`라는 인터페이스로 추상화하고, 이를 목으로 만들어 테스트하는 것이 합당할까?

결론부터 말하면, **그렇지 않다.** `IDomainLogger`를 목으로 만드는 것은 좋은 생각이 아니다. 이는 `IDomainLogger`가 시스템의 최종 출력이 아니기 때문이다.

사용자나 클라이언트가 관심을 갖는 것은 로그 메시지가 `IDomainLogger` 인터페이스에 전달되었다는 사실이 아니다. 그들이 관심을 갖는 것은 그 로그가 **최종적으로 어디에 어떻게 기록되었는가**이다. 예를 들어, 감사 로그가 특정 파일에 특정 형식으로 저장되어야 한다거나, 데이터베이스의 `AUDIT_LOG` 테이블에 기록되어야 한다는 것이 진짜 비즈니스 요구사항이다.

`IDomainLogger` 인터페이스를 목으로 만들어 `log()` 메서드 호출을 검증하는 것은, 시스템이 최종 목적지에 도달하기 전에 중간 다리만 건넜는지를 확인하는 것과 같다. 이 테스트는 `IDomainLogger`의 실제 구현체(`FileDomainLogger`나 `DatabaseDomainLogger`)에 버그가 있더라도 통과해버리는 '거짓 음성'을 유발할 수 있다.

따라서 감사 로그와 같이 비즈니스적으로 중요한 출력을 테스트하는 올바른 방법은 다음과 같다.

1. **애플리케이션이 출력을 생성하게 한다.** (예: `orderService.completeOrder()`)
2. **최종 목적지에서 그 출력을 직접 확인한다.**
  * 만약 파일에 기록하는 것이 요구사항이라면, 테스트 실행 후 해당 파일이 실제로 생성되었는지, 그리고 그 내용이 기대하는 형식과 일치하는지를 파일 시스템 API를 통해 직접 읽어서 검증해야 한다.
  * 만약 데이터베이스 테이블에 기록하는 것이 요구사항이라면, 테스트 실행 후 해당 테이블을 직접 조회하여 레코드가 올바르게 삽입되었는지 검증해야 한다.

이러한 테스트는 더 이상 단위 테스트가 아니라, 실제 파일 시스템이나 데이터베이스와 연동하는 **통합 테스트**의 영역이다. 이처럼 시스템의 최종 출력을 검증하는 것은 목을 사용하는 것보다 훨씬 더 높은 신뢰도를 제공하며, 이것이 바로 통합 테스트가 필요한 중요한 이유 중 하나이다.

## 9.2 목 처리에 대한 모범 사례

이제 목을 사용할 때 흔히 저지르는 실수를 피하고, 목을 명확하고 효과적으로 사용하기 위한 몇 가지 구체적인 모범 사례를 정리해 보자.

### 9.2.1 목은 통합 테스트만을 위한 것

이 책의 핵심적인 주장 중 하나는 **목을 오직 통합 테스트에서만 사용해야 한다는 것**이다. 더 정확히 말하면, **비관리 외부 의존성과의 경계를 검증하는 통합 테스트**에서만 목을 사용해야 한다.

우리가 정의한 **단위 테스트**, 즉 고전파 스타일의 단위 테스트는 프로세스 내부의 협력 객체들을 실제 객체로 사용하고, 외부 의존성은 스텁(Stub)으로 대체하여 SUT의 최종 상태나 반환 값을 검증하는 것을 목표로 한다. 이 정의에 따르면, 단위 테스트에서는 상호작용을 검증하는 목(`verify`)을 사용할 이유가 전혀 없다.

목은 SUT가 우리가 제어할 수 없는 외부 시스템(예: 외부 결제 API, 이메일 서버)에 올바른 명령을 내렸는지를 확인하는 최후의 수단이다. 이러한 검증은 본질적으로 우리 시스템의 일부와 외부 시스템의 일부(API 명세)가 어떻게 '통합'되는지를 확인하는 행위이므로, 통합 테스트의 범주에 속한다고 보는 것이 타당하다.

물론, 런던파 개발자들은 이 주장에 동의하지 않을 것이다. 하지만 이 책에서 일관되게 주장하는 '리팩터링 내성이 강하고 가치 있는 테스트'라는 관점에서 볼 때, 목의 사용을 통합 테스트의 영역으로 제한하는 것은 테스트 스위트의 전반적인 품질과 유지보수성을 향상시키는 매우 효과적인 전략이다.

### 9.2.2 테스트당 목이 하나일 필요는 없음

"하나의 테스트에서는 하나의 목만 사용해야 한다"는 조언을 들어본 적이 있을 것이다. 이는 "하나의 테스트에서는 하나의 개념만 검증해야 한다"는 더 큰 원칙에서 파생된 것으로, 테스트의 초점을 명확하게 유지하려는 좋은 의도를 가지고 있다.

하지만 이 규칙을 너무 기계적으로 적용할 필요는 없다. 만약 SUT가 수행하는 하나의 논리적인 동작이 결과적으로 두 개의 다른 외부 시스템에 각각 명령을 보내는 것이라면, 이 두 개의 상호작용을 하나의 테스트 안에서 모두 검증하는 것이 더 합리적일 수 있다.

예를 들어, '사용자 탈퇴' 기능은 개인정보 보호법에 따라 사용자 정보를 데이터베이스에서 삭제하고, 마케팅 부서의 외부 시스템에도 '구독 해지' API를 호출해야 할 수 있다. 이 경우, `userRepository.delete()`가 호출되었는지와 `marketingApi.unsubscribe()`가 호출되었는지를 하나의 통합 테스트에서 검증하는 것은 '사용자 탈퇴'라는 단일한 비즈니스 시나리오를 온전히 검증하는 자연스러운 방법이다.

이를 위해 두 개의 별도 테스트를 만드는 것은 오히려 시나리오를 파편화시키고, 불필요한 코드 중복을 낳을 수 있다. 중요한 것은 목의 개수가 아니라, 테스트가 검증하려는 **비즈니스 시나리오의 응집성**이다.

### 9.2.3 호출 횟수 검증하기

목을 사용할 때, `verify(mock).someMethod()`와 같이 단순히 메서드가 호출되었는지 여부만 검증하는 것보다, `verify(mock, times(N)).someMethod()`처럼 **정확한 호출 횟수를 명시하는 것이 더 좋다.**

호출 횟수를 명시하면 테스트가 훨씬 더 정확해진다. 예를 들어, 네트워크 재시도 로직을 테스트한다고 가정해 보자. 외부 API 호출이 실패했을 때, 최대 3번까지 재시도해야 한다는 요구사항이 있다. 이 경우, `verify(apiMock, times(3)).callApi()`와 같이 호출 횟수를 정확히 3번으로 검증해야만 재시도 로직이 올바르게 구현되었음을 보장할 수 있다. 단순히 `verify(apiMock).callApi()`라고만 하면, 단 한 번만 호출되었어도 테스트가 통과해버리는 문제가 발생한다.

호출 횟수를 명시하는 것은 테스트를 약간 더 취약하게 만들 수 있지만(예: 재시도 횟수 정책이 3번에서 2번으로 바뀌면 테스트를 수정해야 함), 이 경우에는 회귀 방지 능력을 높여 얻는 이득이 더 크다. 이처럼 호출 횟수가 비즈니스적으로 중요한 의미를 가질 때는 반드시 검증에 포함해야 한다.

### 9.2.4 보유 타입만 목으로 처리하기

이것은 매우 중요한 원칙이다. **SUT가 직접 '보유(own)'하고 있지 않은 타입은 절대 목으로 만들어서는 안 된다.**

여기서 '보유한 타입'이란, 현재 개발하고 있는 프로젝트나 모듈 내에서 직접 정의한 인터페이스나 클래스를 의미한다. 반면, '보유하지 않은 타입'이란 외부 라이브러리나 프레임워크가 제공하는 클래스나 인터페이스를 말한다. 예를 들어, `java.util.List`나 스프링 프레임워크의 `RestTemplate` 같은 것들이 여기에 해당한다.

외부 라이브러리의 클래스를 목으로 만드는 것은 매우 나쁜 생각이다. 그 이유는 다음과 같다.

1. **구현 세부 사항 유출**: 외부 라이브러리의 내부 동작 방식을 우리가 가정하고 목을 설정하게 된다. 만약 라이브러리가 업데이트되면서 내부 동작이 바뀌면, 우리 코드는 문제가 없더라도 목 설정이 더 이상 유효하지 않아 테스트가 실패하게 된다.
2. **불완전한 흉내**: 라이브러리가 제공하는 모든 복잡한 동작을 우리가 목으로 완벽하게 흉내 내는 것은 거의 불가능하다. 이는 실제 환경과의 차이를 만들어내고 테스트의 신뢰도를 떨어뜨린다.

외부 라이브러리와의 연동이 필요하다면, 그 라이브러리를 직접 사용하는 대신, 우리 프로젝트 내에 해당 라이브러리를 감싸는 **래퍼(Wrapper) 또는 어댑터(Adapter) 클래스**를 만들어야 한다. 이 래퍼는 우리가 '보유한' 타입이다. 그리고 우리의 서비스 코드는 이 래퍼 인터페이스에만 의존해야 한다.

**나쁜 예:**

```java
public class MyService {
    private final RestTemplate restTemplate; // 보유하지 않은 타입을 직접 의존

    public void doSomething() {
        // restTemplate을 직접 사용...
    }
}
```

**좋은 예:**

```java
// 우리가 직접 정의한, 보유한 인터페이스
public interface MyApiClient {
    SomeData getData();
}

// 보유한 인터페이스의 구현체 (어댑터)
@Component
public class RestTemplateApiClientAdapter implements MyApiClient {
    private final RestTemplate restTemplate;

    public SomeData getData() {
        // 여기서 RestTemplate을 사용...
    }
}

// 서비스는 이제 보유한 인터페이스에만 의존한다.
public class MyService {
    private final MyApiClient apiClient; 

    public void doSomething() {
        apiClient.getData();
    }
}
```

이렇게 하면, 테스트 시 `MyApiClient` 인터페이스를 목으로 만들어 `MyService`를 쉽게 테스트할 수 있다. `RestTemplate` 자체의 복잡한 동작을 흉내 낼 필요가 전혀 없다. 그리고 `RestTemplateApiClientAdapter` 클래스는 실제 `RestTemplate`을 사용하여 외부 API와 통신하는 통합 테스트를 통해 검증하면 된다. 이 원칙은 우리 코드와 외부 세계 사이에 명확한 경계를 설정하고, 테스트의 안정성과 유지보수성을 크게 향상시킨다.
