이 장에서는 우리가 배운 모든 원칙을 위배하는 대표적인 단위 테스트 안티 패턴들을 하나씩 살펴본다. 이 안티 패턴들은 단순히 '잘못된 코드' 목록이 아니다. 이들은 종종 테스트 코드 자체의 문제뿐만 아니라, 테스트 대상이 되는 제품 코드의 설계가 잘못되었다는 것을 알려주는 중요한 '설계의 냄새(Design Smell)'이기도 하다.

이 장에서 다루는 안티 패턴들을 이해하면, 왜 비공개 메서드를 직접 테스트하는 것이 나쁜 생각인지, 왜 테스트를 위해 제품 코드의 캡슐화를 깨서는 안 되는지, 그리고 시간과 같은 다루기 힘든 의존성을 어떻게 처리해야 하는지에 대한 명확한 해답을 얻게 될 것이다. 이러한 함정들을 피하는 법을 배우는 것은 가치 있는 테스트를 작성하는 기술의 마지막 퍼즐 조각을 맞추는 것과 같다.

## 11.1 비공개 메서드 단위 테스트

개발자들이 단위 테스트에 대해 가지는 가장 흔한 질문 중 하나는 "비공개(private) 메서드는 어떻게 테스트하나요?"이다. 그리고 이에 대한 가장 올바른 대답은 "**테스트하지 않는다**"이다. 비공개 메서드를 직접 단위 테스트하려는 시도는 단위 테스트의 가장 근본적인 원칙을 위배하는 대표적인 안티 패턴이다.

단위 테스트의 대상은 클래스의 공개된 API(public methods)를 통해 드러나는 '식별 가능한 동작'이어야 한다. 공개 메서드가 바로 우리가 외부에 제공하기로 약속한 '단위 작업(unit of work)'이다. 반면, 비공개 메서드는 이 단위 작업을 완수하기 위해 내부적으로 사용되는 도우미(helper)일 뿐이며, 외부에는 공개되지 않은 구현 세부 사항에 해당한다. 구현 세부 사항을 테스트하는 것은 테스트를 취약하게 만드는 가장 빠른 지름길이다.

### 11.1.1 비공개 메서드와 테스트 취약성

비공개 메서드를 테스트하기 위해 자바의 리플렉션(Reflection) API와 같은 기술적인 트릭을 사용하는 것은 테스트와 제품 코드를 매우 강하게 결합시킨다. 이렇게 작성된 테스트는 극도로 취약하며, 거짓 양성(False Positive)의 온상이 된다.

예를 들어, `SomeService` 클래스에 `process()`라는 공개 메서드와, 이 메서드가 내부적으로 사용하는 `calculateHelper()`라는 비공개 메서드가 있다고 가정하자. 만약 우리가 리플렉션을 사용해 `calculateHelper()`를 위한 별도의 테스트를 작성했다면 어떤 일이 벌어질까?

개발자가 `SomeService` 클래스를 리팩터링하여 `calculateHelper()`의 이름을 `calculateSubTotal()`로 바꾸거나, 혹은 그 로직을 `process()` 메서드 안으로 인라인(inline) 시켰다고 해보자. `process()` 메서드의 최종적인 동작, 즉 외부에서 식별 가능한 동작은 전혀 변하지 않았다. 하지만 `calculateHelper()`라는 비공개 메서드는 더 이상 존재하지 않으므로, 그것을 테스트하던 코드는 즉시 컴파일 에러와 함께 실패한다.

이것이 바로 리팩터링 내성을 파괴하는 전형적인 시나리오이다. 실제 버그는 없음에도 불구하고, 단순히 내부 구현을 개선했다는 이유만으로 테스트가 실패하는 것이다. 이러한 경험이 반복되면 개발자는 리팩터링을 주저하게 되고, 테스트 스위트 전체를 불신하게 된다.

### 11.1.2 비공개 메서드와 불필요한 커버리지

어떤 개발자들은 코드 커버리지(Code Coverage) 수치를 높이기 위해 비공개 메서드 테스트가 필요하다고 주장하기도 한다. 이는 커버리지라는 지표를 근본적으로 오해한 것이다.

만약 어떤 비공개 메서드에 중요한 로직이 담겨 있다면, 그 로직은 반드시 어떤 공개 메서드에 의해서든 호출될 것이다. 따라서 그 공개 메서드에 대한 테스트를 올바르게 작성했다면, 비공개 메서드의 코드는 자연스럽게 실행되어 커버리지에 포함된다.

만약 어떤 테스트도 해당 비공개 메서드를 커버하지 못한다면, 이는 두 가지 가능성을 시사한다. 첫째, 공개 메서드에 대한 테스트 케이스가 부족하다는 신호이다. 이 경우, 비공개 메서드를 직접 테스트할 것이 아니라, 그 메서드를 호출하는 시나리오를 빠뜨린 공개 메서드의 테스트를 보강해야 한다. 둘째, 해당 비공개 메서드가 사실은 어디에서도 호출되지 않는 '죽은 코드(Dead Code)'일 수 있다. 이 경우, 해당 코드는 테스트할 것이 아니라 삭제해야 한다.

단순히 커버리지 숫자 100%를 달성하기 위해 비공개 메서드를 테스트하는 것은 아무런 가치를 창출하지 못하는 허영심 메트릭(vanity metric)에 불과하다.

### 11.1.3 비공개 메서드 테스트가 타당한 경우

"그래도 이 비공개 메서드는 너무 복잡해서 따로 테스트하지 않으면 불안한데요?" 라고 느끼는 순간이 있을 수 있다. 이 느낌은 매우 중요하며, 무시해서는 안 된다. 하지만 이때의 올바른 반응은 비공개 메서드를 테스트할 방법을 찾는 것이 아니라, **"왜 이 비공개 메서드가 이렇게 복잡해졌을까?"**라고 질문하는 것이다.

**비공개 메서드를 따로 테스트하고 싶다는 욕구는, 해당 메서드가 너무 많은 책임을 가지고 있다는 강력한 설계의 냄새(Design Smell)이다.** 그 비공개 메서드는 아마도 현재 클래스의 주된 책임과는 다른, 독립적인 책임을 수행하고 있을 가능성이 높다.

이 문제에 대한 올바른 해결책은 **리팩터링**이다. 그 복잡한 로직을 가진 비공개 메서드를 새로운 클래스의 **공개(public) 메서드**로 추출해야 한다. 이렇게 새로 추출된 클래스는 이제 명확하고 단일한 책임을 가지게 되며, 외부 의존성이 거의 없는 3사분면의 코드가 될 가능성이 높다. 이제 이 새로운 클래스는 그 자체로 완벽하고 테스트하기 쉬운 단위가 된다.

예를 들어, `OrderService` 내부에 주문 번호를 생성하는 복잡한 로직이 `private String generateOrderNumber()` 라는 메서드에 있었다면, 이를 `OrderNumberGenerator` 라는 새로운 클래스의 `public String generate()` 메서드로 추출하는 것이다. 이제 우리는 `OrderNumberGenerator`를 마음껏 단위 테스트할 수 있으며, 기존의 `OrderService`는 훨씬 더 단순해진다.

이처럼 비공개 메서드에 대한 고민은 우리를 더 나은 객체지향 설계, 즉 단일 책임 원칙(SRP)을 잘 따르는 설계로 이끄는 긍정적인 신호가 될 수 있다. 해결책은 테스트 트릭이 아니라, 더 나은 설계에 있다.

## 11.2 비공개 상태 노출

비공개 메서드를 테스트하려는 시도와 마찬가지로, **테스트를 위해 클래스의 비공개 필드(private field)를 노출시키는 것** 역시 흔하게 발견되는 안티 패턴이다. 이는 객체의 캡슐화(Encapsulation)를 심각하게 훼손하여 코드를 취약하게 만들고, 테스트가 구현 세부 사항에 강하게 결합되도록 만든다.

많은 개발자가 상태 기반 테스트(State-based testing)를 작성할 때, 메서드 실행 후 객체의 내부 상태가 올바르게 변경되었는지 확인하고 싶은 유혹에 빠진다. 그리고 이 확인을 위해, 오직 테스트 코드에서만 사용할 목적으로 비공개 필드에 대한 public getter를 추가하거나, 필드의 접근 제어자를 `private`에서 `protected`나 `public`으로 약화시킨다.

**안티패턴: 테스트를 위해 getter 노출**

```java
public class ShoppingCart {
    // 테스트에서 이 리스트에 직접 접근하고 싶어서 getter를 추가했다.
    private final List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        // ... 상품 추가 로직 ...
        items.add(item);
    }
    
    // 오직 테스트만을 위한 getter (나쁨!)
    public List<Item> getItems() {
        return items;
    }
}

// 테스트 코드
@Test
void addItem_should_add_item_to_internal_list() {
    // Arrange
    ShoppingCart sut = new ShoppingCart();
    Item item = new Item("상품A", 10000);

    // Act
    sut.addItem(item);

    // Assert
    // getter를 통해 내부 상태(items 리스트)를 직접 검증한다. (나쁨!)
    assertThat(sut.getItems()).hasSize(1);
    assertThat(sut.getItems().get(0)).isEqualTo(item);
}
```

이 접근법의 문제는 5.2.4절에서 논의했던 것과 정확히 같다. 이 테스트는 `ShoppingCart`가 내부적으로 `List<Item>`을 사용하여 상품을 관리한다는 구현 세부 사항에 완벽하게 의존하게 된다. 만약 `ShoppingCart`의 내부 자료 구조를 `Map`으로 리팩터링한다면, `getItems()` 메서드는 더 이상 유효하지 않게 되고 테스트는 즉시 실패한다.

진정한 해결책은 **클래스의 내부 상태가 아닌, 외부에서 식별 가능한 동작이나 결과를 통해 상태 변화를 검증하는 것**이다. `ShoppingCart`의 클라이언트가 정말로 관심을 갖는 것은 내부의 `items` 리스트 그 자체가 아니다. 클라이언트가 궁금해하는 것은 "장바구니에 상품이 몇 개 들어있나?"(`getTotalCount()`) 또는 "총 결제 금액은 얼마인가?"(`getTotalPrice()`)와 같은 의미 있는 정보이다.

따라서 우리는 테스트만을 위한 getter를 만드는 대신, 비즈니스적으로 의미 있는 정보를 제공하는 새로운 public 메서드를 추가해야 한다.

**올바른 접근: 식별 가능한 동작을 통해 검증**

```java
public class ShoppingCart {
    private final List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }
    
    // 비즈니스적으로 의미 있는 정보를 제공하는 public 메서드
    public int getTotalItemCount() {
        return items.size();
    }
}

// 테스트 코드
@Test
void addItem_should_increase_total_item_count() {
    // Arrange
    ShoppingCart sut = new ShoppingCart();
    Item item = new Item("상품A", 10000);

    // Act
    sut.addItem(item);

    // Assert
    // 공개된 동작을 통해 결과를 검증한다. (좋음!)
    assertThat(sut.getTotalItemCount()).isEqualTo(1);
}
```

이처럼 테스트를 위해 제품 코드의 캡슐화를 희생시켜서는 안 된다. 오히려 테스트가 잘 작성되지 않는다는 느낌이 든다면, 그것은 제품 코드의 API 설계가 충분히 비즈니스 의미를 드러내지 못하고 있다는 신호일 수 있다. 테스트하기 어렵다는 사실을 더 나은 설계를 위한 피드백으로 삼아야 한다.

## 11.3 테스트로 유출된 도메인 지식

이 안티 패턴은 조금 더 미묘하다. 이는 테스트 코드 자체가 너무 많은 **도메인 지식(Domain Knowledge)**을 가지게 되어, 제품 코드의 변경에 취약해지는 경우를 말한다. 특히 테스트 데이터를 생성하는 준비(Arrange) 구절에서 자주 발생한다.

예를 들어, 'VIP' 등급의 사용자를 생성하는 테스트를 작성한다고 가정해 보자. VIP 등급이 되기 위한 비즈니스 규칙은 "최근 1년간 누적 구매 금액이 100만 원 이상"이라고 하자.

**안티패턴: 테스트 코드에 도메인 규칙이 하드코딩된 경우**

```java
@Test
void vip_user_should_get_special_discount() {
    // Arrange
    // 'VIP 사용자'를 만들기 위한 도메인 규칙이 테스트 코드에 직접 노출되어 있다.
    // 누적 구매액이 100만 원이라는 '매직 넘버'가 하드코딩되어 있다.
    User sut = new User("testuser", 1_000_000); 

    // Act
    Discount discount = discountService.calculateDiscount(sut, someProduct);

    // Assert
    assertThat(discount.getAmount()).isEqualTo(SPECIAL_DISCOUNT_AMOUNT);
}
```

이 테스트의 문제는 무엇일까? 만약 비즈니스 정책이 변경되어 VIP 등급의 기준이 "누적 구매액 100만 원"에서 "120만 원"으로 상향된다면, 제품 코드의 규칙은 물론이고 이 테스트 코드 역시 찾아서 수정해야 한다. 만약 이와 유사한 테스트가 여러 개 있다면, 개발자는 모든 테스트를 일일이 찾아다니며 숫자 1000000을 1200000으로 바꿔야 하는 번거로운 작업을 해야 한다. 이는 명백히 유지보수성을 해치는 요인이다.

이러한 도메인 지식은 테스트 코드가 아니라 **제품 코드**가 가지고 있어야 할 책임이다. 테스트 코드는 "VIP 사용자는 특별 할인을 받는다"는 사실만 알면 충분하며, "어떻게 해야 VIP 사용자가 되는가"에 대한 세부적인 규칙까지 알 필요는 없다.

해결책은 3.3.3절에서 배운 **테스트 데이터 빌더(Test Data Builder)나 팩토리 메서드**를 사용하여 도메인 지식을 캡슐화하는 것이다.

**올바른 접근: 팩토리 메서드를 통해 도메인 지식 캡슐화**

```java
// UserFactory 또는 테스트 데이터 빌더 클래스 내부
public class UserFactory {
    // 'VIP 사용자'를 만드는 방법을 이 팩토리가 알고 있다.
    public User createVipUser() {
        // VIP 기준 금액이라는 도메인 규칙이 제품 코드(또는 팩토리) 안에 캡슐화되어 있다.
        return new User("vip_user", Constants.VIP_MINIMUM_PURCHASE_AMOUNT);
    }
}


// 테스트 코드
@Test
void vip_user_should_get_special_discount() {
    // Arrange
    // 테스트는 'VIP 사용자'가 필요하다는 의도만 표현한다.
    // 어떻게 만드는지에 대한 세부 사항은 알지 못한다.
    User sut = userFactory.createVipUser();

    // Act & Assert ...
}
```

이제 VIP 등급의 기준 금액이 변경되더라도, 우리는 `UserFactory`의 `createVipUser` 메서드나 `Constants` 클래스의 상수 값만 수정하면 된다. 이 규칙에 의존하는 모든 테스트 코드는 전혀 수정할 필요가 없다. 이처럼 테스트 코드에서 도메인 생성 규칙과 같은 세부 지식을 분리해 내는 것은 테스트의 유지보수성을 극적으로 향상시키는 매우 중요한 습관이다.

## 11.4 코드 오염

**코드 오염(Code Pollution)**은 오직 테스트만을 용이하게 할 목적으로, 비즈니스적인 이유 없이 제품 코드에 코드를 추가하거나 기존 코드를 수정하는 모든 행위를 의미한다. 앞서 살펴본 '비공개 상태 노출' 역시 코드 오염의 한 종류로 볼 수 있다.

제품 코드는 오직 비즈니스 요구사항과 애플리케이션의 기능을 구현하기 위해서만 존재해야 한다. 테스트를 위해 제품 코드의 설계 원칙(캡슐화 등)을 훼손하거나, 불필요한 메서드나 클래스를 추가하는 것은 주객이 전도된 것이다. 테스트는 제품 코드를 지원하고 그 품질을 보장하기 위한 수단이지, 그 자체가 목적이 되어서는 안 된다.

코드 오염의 흔한 예는 다음과 같다.

* 테스트에서 상태를 확인하기 위해 불필요한 public getter 추가하기
* 테스트에서 의존성을 주입하기 위해 제품 로직에 필요 없는 setter 추가하기
* 테스트를 위해 접근 제어자를 `private`에서 `protected`나 `public`으로 변경하기
* 인터페이스에 오직 테스트에서만 사용될 메서드를 추가하기

이러한 코드 오염은 제품 코드의 설계를 왜곡시키고, API를 사용하는 다른 개발자들에게 혼란을 주며, 장기적으로 시스템의 유지보수성을 떨어뜨린다.

만약 코드를 테스트하기 어렵다면, 그 해결책은 제품 코드를 '오염'시키는 것이 아니라, **테스트하기 쉬운 방향으로 리팩터링**하는 것이다. 또는, 해당 코드에 대한 테스트 전략 자체를 다시 고민해봐야 한다. 예를 들어, 단위 테스트가 어렵다면 통합 테스트가 더 적합한 대상은 아닌지 검토해 보아야 한다. 항상 기억해야 할 것은, **테스트는 제품 코드의 하인이 되어야지, 주인이 되어서는 안 된다는 것**이다.

## 11.5 구체 클래스를 목으로 처리하기

이것은 9.2.4절에서 다룬 '보유 타입만 목으로 처리하기' 원칙의 연장선에 있는 안티 패턴이다. **인터페이스가 아닌 구체 클래스(Concrete Class)를 직접 목으로 만드는 것**은 일반적으로 피해야 할 관행이다.

스프링 생태계에서 개발하다 보면, 다른 서비스 클래스(`OtherService`)에 의존하는 서비스 클래스(`MyService`)를 테스트해야 하는 경우가 많다. 이때 많은 개발자가 `OtherService` 구체 클래스를 직접 목으로 만든다.

**안티패턴: 구체 클래스를 목으로 처리**

```java
@ExtendWith(MockitoExtension.class)
class MyServiceTest {
    @Mock
    private OtherService otherServiceMock; // 구체 클래스를 직접 목으로!

    @InjectMocks
    private MyService sut;

    @Test
    void testSomething() {
        // Arrange
        when(otherServiceMock.doSomething()).thenReturn("some result");

        // Act & Assert ...
    }
}
```

Mockito와 같은 현대적인 목킹 프레임워크는 클래스도 목으로 만들 수 있는 강력한 기능을 제공하기 때문에 기술적으로는 이 코드가 동작한다. 하지만 이는 몇 가지 문제를 야기한다.

1. **테스트와 구현의 강한 결합**: `MyService`는 이제 `OtherService`라는 특정 '구현체'에 직접 의존하게 된다. 만약 나중에 `OtherService`의 역할을 수행하는 새로운 `NewCoolService`가 등장하여 `MyService`가 이를 사용하도록 변경된다면, `MyServiceTest`는 필드의 타입부터 모든 목 설정까지 완전히 새로 작성해야 한다.
2. **설계 원칙 위배**: 이는 '구현이 아닌 인터페이스에 의존하라'는 객체지향의 중요한 설계 원칙(의존성 역전 원칙, DIP의 일부)을 위반하는 것이다. 좋은 설계는 역할(인터페이스)과 구현(클래스)을 분리한다.
3. **목킹의 복잡성 증가**: 구체 클래스는 자신이 상속한 다른 클래스나 인터페이스의 수많은 메서드를 모두 포함하고 있다. 이 클래스를 목으로 만들면, 우리가 재정의하려는 메서드 외에도 프레임워크가 내부적으로 호출하는 다른 메서드들의 동작까지 흉내 내야 하는 복잡한 상황에 부딪힐 수 있다.

올바른 해결책은 명확하다. `MyService`가 의존해야 하는 것은 `OtherService`라는 구체적인 클래스가 아니라, `OtherService`가 수행하는 **역할**을 정의하는 새로운 인터페이스(예: `OtherServicePort`)여야 한다.

**올바른 접근: 인터페이스를 목으로 처리**

```java
// 역할을 정의하는 인터페이스
public interface OtherServicePort {
    String doSomething();
}

// 인터페이스의 구현체
@Service
public class OtherService implements OtherServicePort {
    @Override
    public String doSomething() { /* ... */ }
}

// 서비스는 인터페이스에 의존한다.
@Service
public class MyService {
    private final OtherServicePort otherServicePort;
    // ...
}


// 테스트는 인터페이스를 목으로 만든다.
@ExtendWith(MockitoExtension.class)
class MyServiceTest {
    @Mock
    private OtherServicePort otherServicePortMock; // 인터페이스를 목으로! (좋음)

    @InjectMocks
    private MyService sut;
    // ...
}
```

이제 `MyService`는 `OtherServicePort`라는 역할에만 의존하므로, 그 뒤에 어떤 구현체가 오더라도 영향을 받지 않는다. 테스트 역시 깨끗한 인터페이스를 목으로 만들면 되므로 훨씬 더 단순하고 안정적이 된다. 구체 클래스를 목으로 만들고 싶다는 생각이 든다면, 이는 대부분의 경우 의존성을 인터페이스를 통해 추상화할 기회를 놓치고 있다는 신호이다.

## 11.6 시간 처리하기

시간(Time)은 테스트하기 가장 까다로운 요소 중 하나이다. `LocalDateTime.now()`나 `new Date()`와 같이 현재 시간을 직접 호출하는 코드는 테스트를 **비결정적(non-deterministic)**으로 만든다. 테스트는 실행할 때마다 현재 시간이 달라지므로, 특정 시간에 의존하는 로직은 어제는 성공했지만 오늘은 실패하는 예측 불가능한 상태가 된다.

예를 들어, "게시물은 생성 후 24시간 동안만 수정할 수 있다"는 비즈니스 규칙을 테스트해야 한다고 가정해 보자.

**안티패턴: 시간을 직접 호출**

```java
public class Post {
    private LocalDateTime createdAt;

    public Post() {
        this.createdAt = LocalDateTime.now(); // 현재 시간을 직접 호출 (나쁨!)
    }

    public boolean isEditable() {
        return createdAt.plusHours(24).isAfter(LocalDateTime.now());
    }
}

// 이 테스트는 실행 시점에 따라 성공/실패가 달라진다.
@Test
void post_is_editable_within_24_hours() {
    // Arrange
    Post sut = new Post();

    // Act & Assert
    // 이 테스트는 Post가 생성된 직후에는 성공하지만,
    // 하루가 지난 뒤에 실행하면 실패한다!
    assertThat(sut.isEditable()).isTrue();
}
```

이처럼 테스트의 성공 여부가 외부 환경(현재 시간)에 의해 좌우되는 것은 절대적으로 피해야 한다. 해결책은 시간에 대한 의존성을 제어 가능하게 만드는 것이다. 여기에는 두 가지 주요 접근법이 있다.

### 11.6.1 앰비언트 컨텍스트로서의 시간

앰비언트 컨텍스트(Ambient Context) 패턴은 시간과 같이 시스템 전반에 걸쳐 사용되는 '주변 환경' 의존성을 정적(static) 클래스를 통해 제어하는 방식이다. `Clock`이라는 정적 클래스를 만들고, 현재 시간을 얻는 모든 코드가 `LocalDateTime.now()` 대신 `Clock.now()`를 호출하도록 만든다.

```java
public class Clock {
    private static Supplier<LocalDateTime> supplier = LocalDateTime::now;

    public static LocalDateTime now() {
        return supplier.get();
    }
    
    // 테스트에서만 사용할 메서드
    public static void fix(LocalDateTime fixedDateTime) {
        supplier = () -> fixedDateTime;
    }
    
    public static void reset() {
        supplier = LocalDateTime::now;
    }
}
```

이제 테스트 코드에서는 `Clock.fix()` 메서드를 사용하여 시간을 특정 시점으로 고정시킬 수 있다.

```java
@AfterEach
void tearDown() {
    Clock.reset(); // 각 테스트가 끝난 후 시간을 원래대로 되돌려 놓는다.
}

@Test
void post_is_not_editable_after_24_hours() {
    // Arrange
    LocalDateTime creationTime = LocalDateTime.of(2025, 1, 1, 10, 0);
    Clock.fix(creationTime); // 시간을 2025년 1월 1일 10시로 고정
    Post sut = new Post();

    // Act
    LocalDateTime twentyFiveHoursLater = creationTime.plusHours(25);
    Clock.fix(twentyFiveHoursLater); // 시간을 25시간 뒤로 이동

    // Assert
    assertThat(sut.isEditable()).isFalse();
}
```

이 방식은 코드를 거의 변경하지 않고도 시간을 제어할 수 있어 편리하다. 하지만 정적 상태를 사용하는 것은 본질적으로 전역 변수와 같아서, 테스트 간의 격리를 해칠 위험이 있고 병렬 테스트 실행 시 문제가 될 수 있다.

### 11.6.2 명시적 의존성으로서의 시간

더 깨끗하고 권장되는 방법은 시간을 다른 의존성과 마찬가지로 **명시적인 의존성**으로 취급하고, 인터페이스를 통해 주입하는 것이다. 자바 8부터는 `java.time.Clock` 이라는 훌륭한 내장 클래스를 이 용도로 사용할 수 있다.

```java
public class Post {
    private LocalDateTime createdAt;
    
    // Clock 인터페이스를 생성자를 통해 주입받는다.
    public Post(java.time.Clock clock) {
        this.createdAt = LocalDateTime.now(clock);
    }
    
    public boolean isEditable(java.time.Clock clock) {
        return createdAt.plusHours(24).isAfter(LocalDateTime.now(clock));
    }
}
```

이제 제품 코드에서는 `java.time.Clock.systemDefaultZone()`을 주입하여 실제 시간을 사용하고, 테스트 코드에서는 `java.time.Clock.fixed(...)`를 사용하여 특정 시점으로 고정된 시계를 주입할 수 있다.

```java
@Test
void post_is_not_editable_after_24_hours() {
    // Arrange
    LocalDateTime creationTime = LocalDateTime.of(2025, 1, 1, 10, 0);
    // 고정된 시간을 제공하는 Clock 객체를 만든다.
    java.time.Clock creationClock = java.time.Clock.fixed(
            creationTime.toInstant(ZoneOffset.UTC), ZoneOffset.UTC);
    
    Post sut = new Post(creationClock);

    // Act
    LocalDateTime twentyFiveHoursLater = creationTime.plusHours(25);
    java.time.Clock laterClock = java.time.Clock.fixed(
            twentyFiveHoursLater.toInstant(ZoneOffset.UTC), ZoneOffset.UTC);

    // Assert
    assertThat(sut.isEditable(laterClock)).isFalse();
}
```

이 방식은 의존성 주입 원칙을 완벽하게 따르므로, 코드가 훨씬 더 명시적이고 테스트하기 쉬워진다. 시간이라는 까다로운 의존성을 다른 일반적인 의존성과 동일한 방식으로 다룰 수 있게 되는 것이다. 대부분의 경우, 이 명시적 의존성 주입 방식이 앰비언트 컨텍스트 패턴보다 선호되는 접근법이다.

## 11.7 결론

이번 장에서는 단위 테스트의 가치를 떨어뜨리고 유지보수성을 해치는 여러 가지 대표적인 안티 패턴에 대해 알아보았다.

우리는 **비공개 메서드**나 **비공개 상태**를 직접 테스트하려는 시도가 캡슐화를 깨고 테스트를 구현 세부 사항에 결합시키는 나쁜 관행임을 확인했다. 이러한 욕구는 제품 코드의 설계가 잘못되었다는 신호이며, 해결책은 테스트 트릭이 아닌 리팩터링에 있다. 또한, **테스트로 도메인 지식이 유출**되거나 **테스트를 위해 제품 코드가 오염**되는 것을 방지하여 테스트와 제품 코드의 책임을 명확히 분리해야 함을 배웠다.

기술적인 측면에서는 **구체 클래스**가 아닌 인터페이스를 목으로 처리하여 유연하고 테스트 가능한 설계를 유지해야 하며, **시간**과 같이 제어하기 힘든 의존성은 명시적인 의존성 주입을 통해 제어 가능하게 만들어야 한다는 것을 배웠다.

이러한 안티 패턴들을 이해하고 피하는 것은, 긍정적인 패턴을 배우는 것만큼이나 중요하다. 이로써 우리는 좋은 테스트를 작성하는 방법뿐만 아니라, 나쁜 테스트를 만들지 않는 방법까지 모두 갖추게 되었다. 이 지식들을 바탕으로, 우리는 이제 어떤 코드베이스를 마주하더라도 자신감을 갖고 가치 있는 테스트를 작성하고, 이를 통해 소프트웨어의 품질과 개발 생산성을 지속적으로 향상시킬 수 있을 것이다.
