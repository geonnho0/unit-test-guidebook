지금까지 우리는 단위 테스트의 정의와 구조에 대해 살펴보았다. 하지만 구조적으로 훌륭한 테스트라고 해서 반드시 '좋은' 테스트라고 할 수는 없다. 좋은 테스트는 프로젝트에 실질적인 가치를 더하고 개발자의 생산성을 높이는 자산이 되어야 한다. 그렇다면 무엇이 테스트의 가치를 결정하는가?

이 장에서는 좋은 단위 테스트를 구성하는 네 가지 핵심적인 속성을 깊이 있게 탐구한다. 이 네 가지 요소는 바로 **회귀 방지, 리팩터링 내성, 빠른 피드백, 그리고 유지보수성**이다. 이 요소들은 때때로 서로 상충 관계에 놓이기도 한다. 예를 들어, 회귀 방지 능력을 극대화하기 위해 테스트 범위를 넓히면 피드백 속도가 느려질 수 있다. 성공적인 테스트 전략이란 이 네 가지 요소를 올바르게 이해하고, 주어진 상황에 맞게 현명한 트레이드오프를 하는 것에서부터 시작된다.

이 네 가지 요소를 기준으로 테스트를 평가하는 방법을 익히면, 어떤 테스트가 가치 있고 어떤 테스트가 비용만 발생시키는 문제덩어리인지 분별하는 눈을 갖게 될 것이다.

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

이제 좋은 단위 테스트를 정의하는 네 가지 핵심 요소를 하나씩 자세히 들여다보자. 이 요소들은 우리가 작성하는 모든 테스트를 평가하고 개선하는 데 사용할 수 있는 중요한 렌즈 역할을 한다.

### 4.1.1 첫 번째 요소: 회귀 방지

좋은 테스트가 제공하는 가장 중요하고 근본적인 가치는 **회귀(Regression)를 방지**하는 능력이다. 회귀란, 코드 변경으로 인해 기존에 잘 동작하던 기능에 문제가 생기는 현상을 말한다. 훌륭한 테스트 스위트는 이러한 회귀를 개발 수명 주기의 아주 초기 단계에서 자동으로 감지해내는 강력한 안전망 역할을 한다.

테스트의 회귀 방지 능력은 그 테스트가 실행하는 코드의 양과 복잡성에 정비례한다. 단순히 필드 값을 반환하는 간단한 getter 메서드를 검증하는 테스트는 거의 아무런 가치를 제공하지 못한다. 어차피 이 코드는 매우 단순해서 버그가 발생할 가능성이 거의 없기 때문이다. 반면, 여러 조건문과 비즈니스 규칙을 포함하는 복잡한 로직을 통과하는 테스트는 매우 높은 가치를 가진다. 이 코드는 변경 시 예상치 못한 부작용을 일으킬 잠재력이 크므로, 이를 검증하는 테스트는 미래에 발생할 수 있는 심각한 버그를 막아주는 보험이 된다.

이 안전망 덕분에 개발자는 자신감을 갖고 코드를 변경하고 리팩터링할 수 있다. 변경 후에 테스트 스위트 전체를 실행하여 기존 기능이 여전히 안전하다는 것을 몇 분 안에 확인할 수 있다면, 프로젝트는 시간이 지나도 높은 개발 속도를 유지하며 꾸준히 성장할 수 있다.

### 4.1.2 두 번째 요소: 리팩터링 내성

**리팩터링 내성(Resistance to Refactoring)**은 회귀 방지 능력만큼이나 중요하지만, 많은 개발자가 간과하는 요소이다. 이는 기능적인 변경이 없는 코드 리팩터링 작업에 대해 테스트가 실패하지 않고 얼마나 잘 견디는지를 나타내는 척도이다. 다시 말해, 좋은 테스트는 코드의 최종 결과, 즉 '무엇을' 하는지에만 관심을 가지며, 그 결과를 만들어내는 과정인 '어떻게' 하는지에는 무관심해야 한다.

리팩터링은 코드의 겉으로 드러나는 동작은 그대로 유지한 채, 내부 구조를 개선하여 가독성을 높이고 유지보수하기 쉽게 만드는 모든 활동을 의미한다. 예를 들어, 메서드 이름을 더 명확하게 바꾸거나, 복잡한 로직을 여러 개의 작은 비공개 메서드로 추출하거나, 알고리즘을 더 효율적인 방식으로 변경하는 것 등이 모두 리팩터링에 해당한다.

만약 이러한 내부 구조 개선 작업만으로 테스트가 실패한다면, 그 테스트는 리팩터링 내성이 낮은 '깨지기 쉬운 테스트'이다. 이런 테스트는 개발자가 코드를 개선하려는 시도를 방해하고, 실제 버그가 없음에도 불필요한 테스트 수정 작업을 유발하여 생산성을 저하시킨다. 좋은 테스트는 개발자가 안심하고 리팩터링할 수 있는 자유를 주어야 하며, 오직 시스템의 실제 동작이 변경되었을 때만 실패해야 한다.

### 4.1.3 무엇이 거짓 양성의 원인인가?

리팩터링 내성이 낮은 테스트가 유발하는 가장 큰 문제는 **거짓 양성(False Positive)**이다. 거짓 양성이란, 실제 제품 코드에는 아무런 버그가 없음에도 불구하고 테스트가 실패하는 상황을 말한다. 이는 마치 화재가 나지 않았는데 화재 경보기가 울리는 것과 같아서, 개발자들에게 불필요한 혼란과 시간 낭비를 초래한다.

거짓 양성의 근본적인 원인은 테스트가 코드의 **구현 세부 사항(Implementation Details)에 너무 깊게 결합**되어 있기 때문이다. 테스트가 검증해야 할 대상은 해당 코드가 외부에 제공하는 최종적인 결과나 상태 변화이지, 그 결과를 만들어내기 위해 내부적으로 어떤 클래스와 협력하고 어떤 비공개 메서드를 호출하는지가 아니다.

예를 들어, `UserService`를 테스트하면서 `UserService`가 내부적으로 `UserRepository`의 `save` 메서드를 특정 횟수만큼 호출했는지 검증했다고 가정해 보자. 만약 개발자가 리팩터링 과정에서 성능 개선을 위해 여러 개의 `save` 호출을 하나의 `saveAll` 호출로 변경한다면, 최종적으로 데이터베이스에 저장되는 결과는 동일하더라도 기존 테스트는 실패할 것이다. 이것이 바로 구현 세부 사항을 테스트함으로써 발생하는 전형적인 거짓 양성 사례이다. 이러한 거짓 양성이 반복되면 개발자들은 테스트 결과를 불신하게 되고, 결국 테스트 스위트 전체는 무시되고 방치되는 수순을 밟게 된다.

### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기

거짓 양성을 피하고 리팩터링 내성이 강한 테스트를 만들기 위한 해결책은 명확하다. 바로 테스트의 목표를 코드의 내부 구현 과정이 아닌, 외부에서 관찰 가능한 **최종 결과(End Result) 또는 상태 변화**로 삼는 것이다.

이는 테스트를 작성할 때, 해당 코드를 사용하는 '클라이언트'의 입장에서 생각하는 것을 의미한다. 클라이언트는 코드의 내부 구조를 알지 못하며, 알 필요도 없다. 클라이언트에게 중요한 것은 메서드를 호출했을 때 올바른 값이 반환되는지, 또는 시스템의 특정 상태가 기대하는 대로 변경되었는지 뿐이다.

예를 들어, 온라인 쇼핑몰에서 '주문하기' 기능을 테스트한다고 가정해 보자. 구현 세부 사항에 집중하는 테스트는 `OrderService`가 `PaymentGateway`와 `StockManager`를 올바르게 호출하는지를 검증하려 할 것이다. 반면, 최종 결과를 목표로 하는 테스트는 `order()` 메서드를 호출한 후에, 반환된 `Order` 객체의 상태가 '결제 완료'인지, 그리고 데이터베이스에 저장된 상품의 재고가 실제로 줄어들었는지를 확인할 것이다.

후자의 방식은 `OrderService` 내부에서 결제와 재고 관리를 처리하는 로직이 어떻게 변경되더라도, 최종적인 비즈니스 규칙만 지켜진다면 테스트가 계속 성공하도록 보장한다. 이렇게 작성된 테스트만이 실제 회귀를 효과적으로 막아주면서도, 코드 개선 작업을 방해하지 않는 진정으로 가치 있는 테스트가 될 수 있다.

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

지금까지 살펴본 두 가지 핵심 요소, 즉 회귀 방지와 리팩터링 내성은 좋은 테스트가 갖추어야 할 가장 중요한 두 축을 이룹니다. 하지만 이 두 가지 요소는 서로를 밀어내는 힘, 즉 상충 관계(trade-off)에 놓여 있는 경우가 많습니다. 하나의 특성을 극대화하려는 노력이 다른 특성을 저해하는 결과를 낳을 수 있다는 의미입니다.

예를 들어, 회귀 방지 능력을 최고로 높이려면 어떻게 해야 할까요? 아마도 시스템의 모든 코드를 한 번에 실행하는 거대한 엔드 투 엔드 테스트를 작성하는 것이 한 가지 방법일 것입니다. 이 테스트는 코드베이스의 아주 넓은 범위를 포괄하므로 수많은 잠재적 회귀를 잡아낼 수 있습니다. 하지만 이 테스트는 수많은 클래스의 내부 구현과 상호작용에 의존하게 되므로, 단 하나의 비공개 메서드 이름만 바뀌어도 실패할 수 있습니다. 즉, 리팩터링 내성이 극도로 취약해집니다.

반대로 리팩터링 내성을 최고로 높이려면 어떻게 해야 할까요? 아주 작은 코드 조각, 예를 들어 매개변수 외에는 어떤 의존성도 없는 순수 함수 하나만을 테스트하면 됩니다. 이 테스트는 내부 구현이 어떻게 바뀌든 입력과 출력만 같다면 절대 실패하지 않으므로 리팩터링 내성이 매우 강합니다. 하지만 이 테스트는 코드베이스의 극히 일부만을 실행하므로, 전체 시스템의 관점에서 회귀를 막아주는 능력은 거의 없습니다.

따라서 우리의 목표는 둘 중 하나를 맹목적으로 추구하는 것이 아니라, 이 두 가지 상충되는 특성 사이에서 최적의 균형점을 찾는 것입니다.

### 4.2.1 테스트 정확도 극대화

두 요소 사이의 균형을 설명하는 좋은 개념이 바로 **테스트 정확도(Test Accuracy)**입니다. 의학 진단의 정확도를 생각하면 이해하기 쉽습니다. 좋은 진단 키트는 아픈 사람을 아프다고 정확히 찾아내고(회귀 감지), 건강한 사람은 건강하다고 올바르게 판단해야 합니다(리팩터링 허용).

테스트의 정확도를 극대화한다는 것은, 테스트가 오직 실제 제품 코드에 버그가 있을 때만 실패하고, 코드가 올바르게 동작할 때는(리팩터링을 포함하여) 항상 성공하도록 만드는 것을 의미합니다. 부정확한 테스트는 개발팀의 시간과 신뢰를 갉아먹는 주범입니다. 실제 버그를 놓치거나(부정확), 버그가 없는데도 실패 경고를 울리는(부정확) 테스트는 없는 것보다 못할 수 있습니다.

결국 가치 있는 테스트란 이 정확도가 높은 테스트입니다. 그리고 이 정확도를 높이는 열쇠는 앞서 말했듯이 테스트의 대상을 코드의 내부 구현 세부 사항이 아닌, 외부에서 관찰 가능한 최종 결과로 삼는 것입니다. 최종 결과에 집중하는 테스트는 시스템의 실제 동작 변경(회귀)에는 민감하게 반응하면서도, 그 결과를 만드는 과정의 변경(리팩터링)에는 둔감하게 반응하여 두 마리 토끼를 모두 잡을 수 있는 가장 이상적인 형태에 가깝습니다.

### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계

테스트의 정확도를 논할 때 반드시 이해해야 하는 두 가지 오류 유형이 바로 **거짓 양성(False Positive)**과 **거짓 음성(False Negative)**입니다.

* **거짓 양성 (False Positive)**: 앞서 설명했듯이, 실제 제품 코드에는 버그가 없는데 테스트가 실패하는 경우입니다. 이는 리팩터링 내성이 낮은 테스트의 전형적인 증상입니다.
* **거짓 음성 (False Negative)**: 실제 제품 코드에 버그가 있는데도 테스트가 성공(통과)하는 경우입니다. 이는 회귀 방지 능력이 부족한 테스트에서 발생합니다. 안전망 역할을 해야 할 테스트에 구멍이 뚫려 있는 것과 같습니다.

이 두 가지 오류는 서로 역학 관계에 있습니다. 즉, 한쪽을 줄이려는 노력이 다른 한쪽을 늘리는 경향이 있습니다.

만약 개발팀이 잦은 거짓 양성에 지쳐서 리팩터링 내성을 높이는 데에만 집중한다고 가정해 봅시다. 이들은 테스트가 내부 구현에 의존하지 않도록 매우 관대하고 추상적인 수준에서만 테스트를 작성할 수 있습니다. 그 결과, 리팩터링 시 테스트가 깨지는 일은 줄어들겠지만(거짓 양성 감소), 실제 버그가 발생해도 이를 감지하지 못하고 테스트가 통과해버리는 위험이 커집니다(거짓 음성 증가).

반대로, 단 하나의 버그도 놓치지 않겠다는 생각에 회귀 방지 능력에만 집착할 수도 있습니다. 개발자들은 가능한 모든 코드 경로와 내부 상호작용을 샅샅이 검증하는 매우 촘촘한 테스트를 작성할 것입니다. 그 결과, 버그를 놓칠 가능성은 줄어들겠지만(거짓 음성 감소), 코드의 작은 내부 구조 변경에도 민감하게 반응하여 수많은 테스트가 실패하는 거짓 양성의 늪에 빠지게 됩니다(거짓 양성 증가).

따라서 성공적인 테스트 전략이란 거짓 양성과 거짓 음성을 모두 완전히 없애는 것이 아니라, 이 둘 사이의 긴장을 이해하고 두 종류의 오류를 모두 최소화하는 방향으로 테스트를 설계하고 코드를 구성하는 것입니다. 이것이 바로 개발자에게 실질적인 도움을 주는 테스트 스위트를 만드는 핵심 과제입니다.

## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

앞서 다룬 두 가지 요소가 테스트의 '정확성'과 관련된 핵심 가치였다면, 이어지는 두 요소는 테스트 스위트를 운영하고 유지하는 '비용'과 관련된 실용적인 측면입니다. 아무리 정확한 테스트라도 너무 느리거나 유지보수하기 어렵다면 결국 개발팀의 외면을 받게 됩니다.

**세 번째 요소: 빠른 피드백 (Fast Feedback)**

테스트는 빨라야 합니다. 여기서 '빠르다'는 것은 개발자가 코드 변경 후 테스트 결과를 즉시 확인할 수 있을 정도의 속도를 의미합니다. 이상적으로는 전체 테스트 스위트를 실행하는 데 몇 분 이상 걸리지 않아야 합니다. 빠른 피드백은 개발자의 생산성에 지대한 영향을 미칩니다. 만약 테스트가 몇 초 만에 완료된다면, 개발자는 코드를 수정할 때마다 습관적으로 테스트를 실행하여 '코딩-테스트-리팩터링'의 리듬을 유지할 수 있습니다. 이는 개발자가 깊은 집중 상태(flow state)를 유지하도록 돕고, 버그가 발생하더라도 방금 작성한 코드에서 원인을 쉽게 찾을 수 있게 해줍니다.

반대로 테스트 실행에 30분이 걸린다면 어떻게 될까요? 개발자는 테스트 실행을 하루에 한두 번, 혹은 코드를 커밋하기 직전에만 하게 될 것입니다. 이는 버그가 발생했을 때, 지난 몇 시간 동안 작성한 수많은 코드 변경 사항 중에 원인이 무엇인지 추적하는 것을 매우 어렵게 만듭니다. 결국 테스트는 개발을 돕는 도구가 아니라, 개발 흐름을 끊는 성가신 장애물이 되어버립니다. 테스트 속도를 저해하는 가장 큰 요인은 데이터베이스나 네트워크 통신과 같은 프로세스 외부 의존성과의 연동이며, 좋은 단위 테스트는 이러한 의존성을 제거하여 빠른 속도를 보장해야 합니다.

**네 번째 요소: 유지보수성 (Maintainability)**

테스트 코드 역시 제품 코드와 마찬가지로 유지보수 대상입니다. 테스트 스위트의 유지보수성은 테스트 코드를 이해하고, 수정하고, 실행하는 데 드는 총체적인 노력을 의미합니다. 유지보수성이 낮은 테스트는 그 자체로 또 다른 기술 부채가 되어 프로젝트의 발목을 잡습니다.

테스트의 유지보수성은 여러 요인에 의해 결정됩니다. 첫째, **가독성**입니다. 이름이 불분명하고, AAA 패턴을 따르지 않으며, 구조가 복잡한 테스트는 이해하기 어렵습니다. 둘째, **견고함**입니다. 앞서 말한 리팩터링 내성이 낮은, 즉 쉽게 깨지는 테스트는 실제 버그가 없음에도 계속해서 수정을 요구하므로 유지보수 비용이 매우 높습니다. 셋째, **실행 용이성**입니다. 테스트를 실행하기 위해 복잡한 설정이나 외부 환경에 대한 의존이 필요하다면, 그 테스트는 유지보수하기 어렵다고 할 수 있습니다.

궁극적으로 좋은 테스트는 이 네 가지 요소를 모두 높은 수준으로 만족시켜야 합니다. 하지만 현실에서는 이들 사이에 존재하는 상충 관계 때문에 네 가지를 모두 완벽하게 만족하는 이상적인 테스트를 찾는 것은 매우 어렵습니다.

## 4.4 이상적인 테스트를 찾아서

우리가 꿈꾸는 이상적인 테스트는 어떤 모습일까요? 아마도 다음과 같은 특성을 모두 가질 것입니다.

* 모든 잠재적 버그를 잡아낸다 (최고의 회귀 방지 능력)
* 어떤 리팩터링에도 절대 깨지지 않는다 (완벽한 리팩터링 내성)
* 눈 깜짝할 사이에 실행된다 (가장 빠른 피드백)
* 누구나 한눈에 이해하고 수정할 수 있다 (최상의 유지보수성)

### 4.4.1 이상적인 테스트를 만들 수 있는가?

결론부터 말하자면, 이 네 가지 특성을 100% 만족하는 완벽한 테스트는 현실 세계에 존재하지 않습니다. 이는 네 가지 요소가 서로 상충 관계에 있기 때문입니다. 하나의 가치를 극대화하려는 시도는 필연적으로 다른 가치를 희생시키는 결과를 낳습니다.

따라서 우리의 목표는 존재하지 않는 이상향을 좇는 것이 아니라, 이 네 가지 요소 간의 균형을 이해하고, 우리가 처한 상황에서 가장 가치 있는 조합을 찾아내는 것입니다. 이를 위해 몇 가지 극단적인 테스트 사례를 살펴보며 각 요소가 어떻게 작용하는지 분석해 보겠습니다.

### 4.4.2 극단적인 사례 1: 엔드 투 엔드 테스트

엔드 투 엔드 테스트는 사용자의 시나리오를 처음부터 끝까지, 실제 운영 환경과 거의 동일한 상태에서 검증하는 테스트입니다. 예를 들어, 웹 브라우저를 통해 로그인하고, 상품을 장바구니에 담고, 결제하는 전 과정을 자동화하는 것입니다.

* **회귀 방지**: 매우 높음. 시스템의 모든 구성 요소가 함께 동작하는 것을 검증하므로, 통합 과정에서 발생하는 버그를 잡는 데 매우 효과적입니다. 시스템이 전체적으로 잘 동작한다는 강한 확신을 줍니다.
* **리팩터링 내성**: 매우 낮음. 이 테스트는 UI, API, 서비스, 데이터베이스 등 시스템의 모든 계층에 의존합니다. 이 중 어느 한 곳의 작은 내부 구현만 바뀌어도 쉽게 깨질 수 있어 거짓 양성 발생률이 매우 높습니다.
* **빠른 피드백**: 매우 낮음. 실제 네트워크 통신과 데이터베이스 I/O를 포함하므로 실행 속도가 극도로 느립니다.
* **유지보수성**: 매우 낮음. 느리고, 깨지기 쉬우며, 실패 시 원인을 찾기가 매우 어렵습니다.

**결론**: 회귀 방지 능력이라는 확실한 가치를 제공하지만, 그 비용(느린 속도, 낮은 리팩터링 내성, 높은 유지보수 비용)이 너무 비쌉니다. 따라서 핵심 시나리오에 대해서만 최소한으로 유지해야 합니다.

### 4.4.3 극단적인 사례 2: 간단한 테스트

이번에는 반대쪽 극단에 있는, 아주 간단한 코드를 검증하는 테스트를 생각해 보겠습니다. 예를 들어, `User` 객체의 `getName()` 메서드가 생성자에서 받은 이름을 그대로 반환하는지 확인하는 테스트입니다.

* **회귀 방지**: 거의 없음. 테스트 대상 코드가 너무 단순해서 애초에 버그가 발생할 가능성이 거의 없습니다. 이런 테스트는 의미 있는 회귀를 막아주지 못합니다.
* **리팩터링 내성**: 매우 높음. 외부 의존성이 없고 동작이 단순하여 깨질 일이 거의 없습니다.
* **빠른 피드백**: 매우 높음. 순식간에 실행됩니다.
* **유지보수성**: 매우 높음. 작성하고 이해하기 매우 쉽습니다.

**결론**: 비용은 거의 들지 않지만, 제공하는 가치 또한 거의 없습니다. 코드 커버리지 숫자를 높이는 것 외에는 별다른 의미가 없으며, 이런 테스트를 양산하는 것은 시간 낭비일 수 있습니다.

### 4.4.4 극단적인 사례 3: 깨지기 쉬운 테스트

이번에는 단위 테스트 중에서 가장 문제가 되는 유형인 깨지기 쉬운 테스트입니다. 이는 런던파 스타일을 잘못 적용했을 때 흔히 나타나는 형태로, 테스트 대상 클래스의 모든 협력 객체를 목(Mock)으로 대체하고, SUT가 이 목 객체들과 어떤 순서로, 어떤 메서드를 호출하는지 등 내부 상호작용을 샅샅이 검증하는 테스트입니다.

* **회귀 방지**: 낮음. 이 테스트는 협력 객체와의 '소통 방식'만 검증할 뿐, 그 소통의 결과로 시스템 전체가 올바르게 동작하는지는 보장하지 못합니다. 또한 목 객체가 실제 객체의 동작과 다르게 설정될 경우, 버그가 있어도 테스트가 통과하는 거짓 음성이 발생할 수 있습니다.
* **리팩터링 내성**: 매우 낮음. 테스트가 내부 구현, 즉 클래스 간의 상호작용 방식에 직접적으로 결합되어 있기 때문에, 기능 변경 없는 리팩터링에도 매우 쉽게 깨집니다. 거짓 양성의 주된 원인입니다.
* **빠른 피드백**: 높음. 프로세스 외부 의존성이 없으므로 실행 속도는 빠릅니다.
* **유지보수성**: 매우 낮음. 복잡한 목 설정과 검증 로직으로 인해 가독성이 떨어지고, 잦은 실패로 인해 끊임없는 수정을 요구하여 개발팀의 에너지를 소모시킵니다.

**결론**: 빠르다는 장점 때문에 좋은 단위 테스트처럼 보이지만, 실제로는 낮은 회귀 방지 능력과 최악의 리팩터링 내성으로 인해 프로젝트에 해가 되는 경우가 많습니다. 비용 대비 가치가 가장 낮은, 피해야 할 테스트 유형입니다.

### 4.4.5 이상적인 테스트를 찾아서: 결론

세 가지 극단적인 사례를 통해 우리는 완벽한 테스트란 존재하지 않으며, 각 테스트 유형이 네 가지 요소의 측면에서 서로 다른 장단점을 가짐을 확인했습니다.

그렇다면 우리의 목표는 무엇일까요? 바로 이 극단들 사이의 **'스위트 스팟(Sweet Spot)'**을 찾는 것입니다. 즉, 네 가지 요소가 적절히 균형을 이룬, 가성비 좋은 테스트를 작성하는 것입니다. 이러한 테스트는 다음의 특성을 지향합니다.

* 중요한 비즈니스 로직을 포함하는, 의미 있는 코드 단위를 검증함으로써 **적절한 수준의 회귀 방지 능력**을 가집니다.
* 내부 구현이 아닌 최종 결과에 집중함으로써 **높은 리팩터링 내성**을 확보합니다.
* 데이터베이스와 같은 외부 의존성으로부터 격리되어 **빠른 피드백**을 제공합니다.
* 구조가 명확하고 의도가 잘 드러나 **높은 유지보수성**을 가집니다.

결국 이 책이 지향하는 '좋은 단위 테스트'란 바로 이 스위트 스팟에 위치한 테스트입니다. 이어지는 장들에서는 이러한 균형 잡힌 테스트를 어떻게 설계하고 작성할 수 있는지에 대한 구체적인 기술과 패턴을 탐구해 나갈 것입니다.

## 4.5 대중적인 테스트 자동화 개념 살펴보기

지금까지 논의한 네 가지 요소를 기준으로, 소프트웨어 업계에서 널리 알려진 몇 가지 테스트 자동화 개념들을 다시 비판적인 시각으로 살펴볼 필요가 있습니다. 많은 개발팀이 이러한 개념들을 마치 법칙처럼 받아들이지만, 그 본질적인 의미와 트레이드오프를 이해하지 못한 채 적용하면 오히려 테스트의 가치를 떨어뜨리는 결과를 낳을 수 있습니다.

### 4.5.1 테스트 피라미드 분해

테스트 자동화 전략을 논할 때 가장 자주 등장하는 모델은 바로 **'테스트 피라미드(Test Pyramid)'**입니다. 마이크 콘(Mike Cohn)이 제시한 이 모델은 테스트 스위트를 세 개의 계층으로 나누고, 각 계층의 테스트 양을 시각적으로 표현합니다.

* **UI (또는 엔드 투 엔드) 테스트 (맨 위, 가장 작은 부분)**: 실제 사용자 인터페이스를 통해 시스템 전체를 테스트합니다. 실행이 매우 느리고, 비용이 비싸며, 깨지기 쉽습니다. 따라서 그 수를 최소화해야 합니다.
* **서비스 (또는 통합) 테스트 (중간)**: UI를 거치지 않고 서비스 계층이나 API 엔드포인트를 직접 호출하여 여러 컴포넌트의 통합을 테스트합니다. 엔드 투 엔드 테스트보다 빠르지만, 여전히 외부 의존성(데이터베이스 등)을 포함할 수 있어 단위 테스트보다는 느립니다.
* **단위(Unit) 테스트 (맨 아래, 가장 넓은 부분)**: 개별 컴포넌트나 클래스를 독립적으로 테스트합니다. 실행 속도가 매우 빠르고, 비용이 저렴하며, 안정적입니다. 따라서 테스트 스위트의 대부분을 차지해야 합니다.

테스트 피라미드의 핵심 메시지는 명확합니다. 느리고 비싼 테스트는 줄이고, 빠르고 저렴한 단위 테스트를 많이 작성하라는 것입니다. 이는 빠른 피드백과 비용 효율성 측면에서 매우 합리적인 조언입니다.

하지만 이 모델을 맹목적으로 따를 때 몇 가지 문제가 발생합니다. 첫째, 피라미드 모델은 '단위 테스트'의 정의가 무엇인지 명확히 하지 않습니다. 여기서 말하는 단위 테스트가 앞서 논의한 고전파일까요, 런던파일까요? 만약 개발팀이 런던파 스타일의 깨지기 쉬운 테스트를 '단위 테스트'라고 생각하고 그 수를 무작정 늘린다면, 피라미드의 모양은 유지될지 몰라도 테스트 스위트 전체의 가치는 오히려 떨어질 것입니다.

둘째, 피라미드는 '무엇을' 테스트해야 하는지에 대한 지침을 주지 않습니다. 단지 "단위 테스트를 많이 만들라"는 조언은 개발자들이 코드 커버리지를 높이기 위해 가치가 거의 없는 간단한 테스트(4.4.3절의 예시)를 양산하도록 부추길 수 있습니다. 중요한 것은 테스트의 양이 아니라, 그 테스트가 네 가지 핵심 요소를 얼마나 잘 만족시키며 실질적인 가치를 제공하는지입니다.

따라서 우리는 테스트 피라미드를 양적인 지침이 아니라 질적인 지침으로 재해석해야 합니다. 테스트 스위트의 기반은 네 가지 요소를 가장 잘 만족시키는, 즉 회귀 방지 능력이 높고 리팩터링 내성이 강하며 빠르고 유지보수하기 쉬운 **고품질 단위 테스트**로 구성되어야 합니다. 그 위에 필요한 만큼의 통합 테스트와 최소한의 엔드 투 엔드 테스트를 쌓아 올리는 것이 더 건강한 접근법입니다.

### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

테스트를 접근하는 방식을 크게 두 가지로 나눌 수 있는데, 바로 블랙박스 테스트와 화이트박스 테스트입니다. 이 둘 사이의 선택은 우리가 작성하는 테스트의 성격, 특히 리팩터링 내성에 결정적인 영향을 미칩니다.

* **블랙박스 테스트(Black-box Testing)**: 테스트 대상의 내부 구조나 동작 원리를 전혀 모르는 상태에서, 마치 외부 사용자(클라이언트)처럼 공개된 인터페이스(API)만을 사용하여 테스트하는 방식입니다. 오직 입력과 그에 따른 출력(또는 최종 상태 변화)에만 관심을 가집니다. "무엇을 하는가(what)"를 검증합니다.
* **화이트박스 테스트(White-box Testing)**: 테스트 대상의 내부 구현을 모두 알고 있는 상태에서, 내부의 논리적인 경로, 특정 메서드의 호출 여부, 내부 상태의 변화 등을 세세하게 검증하는 방식입니다. "어떻게 하는가(how)"를 검증합니다.

이 두 가지 접근법을 좋은 단위 테스트의 네 가지 요소, 특히 리팩터링 내성의 관점에서 평가해 봅시다. 블랙박스 테스트는 정의상 내부 구현을 모르기 때문에 리팩터링에 영향을 받지 않습니다. 공개된 API의 명세만 변경되지 않는다면, 내부 구조를 어떻게 개선하든 테스트는 성공할 것입니다. 따라서 **블랙박스 테스트는 본질적으로 리팩터링 내성이 높습니다.**

반면, 화이트박스 테스트는 내부 구현과 강하게 결합되어 있습니다. 내부에서 사용하던 비공개 메서드를 바꾸거나 클래스 간의 상호작용 방식을 변경하면 즉시 테스트가 실패합니다. 이는 **화이트박스 테스트가 깨지기 쉬운 테스트와 거짓 양성의 주된 원인**임을 의미합니다.

이는 앞서 논의한 고전파와 런던파 스타일과도 직접적으로 연결됩니다. 고전파 스타일은 특정 동작 단위의 최종 결과를 검증하므로 블랙박스 테스트에 가깝습니다. 반면, 목 객체를 사용하여 내부 상호작용을 검증하는 런던파 스타일은 대표적인 화이트박스 테스트입니다.

결론적으로, 리팩터링 내성이 강하고 장기적으로 가치 있는 테스트를 작성하기 위해서는 우리는 가능한 한 **블랙박스 테스트 관점을 지향**해야 합니다. 테스트 대상 시스템(SUT)을 하나의 검은 상자로 간주하고, 그 상자의 내부를 들여다보려 하지 말고, 오직 공개된 입출력과 최종 결과에만 집중해야 합니다. 이 원칙을 지키는 것이 개발자에게 진정으로 도움이 되는 테스트를 만드는 가장 중요한 열쇠입니다.
