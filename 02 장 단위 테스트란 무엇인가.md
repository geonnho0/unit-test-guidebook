단위 테스트라는 용어는 소프트웨어 개발 분야에서 가장 널리 쓰이는 용어 중 하나지만, 동시에 가장 모호하게 이해되는 용어이기도 합니다. 개발자들마다 '단위'를 무엇으로 보아야 하는지, 그리고 테스트를 어디까지 '격리'해야 하는지에 대해 서로 다른 생각을 가지고 있습니다. 이러한 생각의 차이는 테스트를 작성하는 방식에 근본적인 영향을 미치며, 이는 곧 테스트 스위트의 품질과 직결됩니다. 이 장에서는 단위 테스트의 정의를 둘러싼 다양한 관점을 살펴보고, 스프링 백엔드 개발자로서 어떤 관점을 취하는 것이 실무적으로 더 유용한지 탐구해 보겠습니다.

## 2.1 '단위 테스트'의 정의

보편적으로 단위 테스트는 다음 세 가지 속성을 갖는 자동화된 테스트로 정의됩니다.

1. 코드의 작은 단위(Unit)를 검증한다.
2. 빠르게 실행된다.
3. 다른 테스트로부터 격리된 상태에서 실행된다.

이 세 가지 속성은 대부분의 개발자가 동의하는 부분입니다. 테스트는 검증 대상이 명확해야 하고, 개발 주기에 통합되어 빠른 피드백을 제공할 수 있을 만큼 신속해야 하며, 다른 테스트의 결과에 영향을 주거나 받지 않아야 합니다. 문제는 첫 번째 속성인 '코드의 작은 단위'와 세 번째 속성인 '격리'의 해석에 있습니다.

특히 '격리' 문제를 어떻게 바라보느냐에 따라 단위 테스트를 작성하는 스타일이 크게 두 갈래로 나뉩니다. 어떤 개발자들은 테스트 대상이 되는 클래스 하나를 제외한 모든 협력 객체로부터의 격리를 주장하는 반면, 다른 개발자들은 데이터베이스나 네트워크와 같은 외부 시스템으로부터의 격리만을 강조합니다. 이 두 가지 접근 방식의 차이를 이해하는 것은 효과적인 테스트 전략을 수립하는 데 매우 중요합니다.

### 2.1.1 격리 문제에 대한 런던파의 접근

단위 테스트의 격리 문제를 엄격하게 해석하는 진영을 '런던파(London School)' 또는 '목 지지파(Mockist School)'라고 부릅니다. 이들은 '단위'를 하나의 클래스로 한정합니다. 따라서 단위 테스트는 오직 하나의 클래스만을 테스트해야 하며, 해당 클래스가 의존하는 다른 모든 클래스(협력 객체)는 테스트 대역(Test Double), 특히 목(Mock)으로 대체되어야 한다고 주장합니다.

런던파의 관점에서 격리의 목표는 테스트 대상 클래스를 협력 객체들로부터 완벽하게 분리하는 것입니다. 만약 테스트가 실패했다면, 그 원인은 오직 테스트 대상 클래스 내부에만 있어야 한다는 생각입니다. 협력 객체의 버그 때문에 테스트가 실패하는 상황을 원천적으로 차단하여, 버그의 위치를 빠르고 정확하게 찾아내는 것을 중요하게 여깁니다. 이러한 접근 방식은 테스트 대상 클래스의 행동뿐만 아니라, 협력 객체와의 '상호작용' 자체를 검증하는 데 초점을 맞추게 됩니다.

### 2.1.2 격리 문제에 대한 고전파의 접근

반면, 격리 문제를 보다 유연하게 해석하는 진영을 '고전파(Classic School)' 또는 '디트로이트파(Detroit School)'라고 합니다. 이들에게 '단위'는 반드시 클래스 하나에 국한되지 않습니다. 하나의 단위는 서로 밀접하게 연관된 여러 클래스의 묶음이 될 수도 있습니다. 즉, 검증하려는 특정 '동작'을 수행하는 단위 전체가 테스트의 대상이 됩니다.

고전파에게 격리의 목표는 각 테스트 케이스를 다른 테스트 케이스로부터 격리하는 것입니다. 또한 데이터베이스, 파일 시스템, 네트워크 통신과 같이 공유되고 불안정한 외부 의존성으로부터 테스트를 격리하는 것을 중요하게 생각합니다. 하지만 테스트 대상이 의존하는 다른 클래스가 메모리 내에서 안정적으로 동작하는 일반적인 객체라면, 굳이 이를 테스트 대역으로 대체하지 않고 실제 객체를 그대로 사용합니다. 이들은 테스트가 실제 운영 환경과 유사한 조건에서 실행될 때 더 높은 가치를 갖는다고 믿으며, 최종적으로 나타나는 '결과'를 검증하는 데 집중합니다.

## 2.2 단위 테스트의 런던파와 고전파

앞서 살펴본 두 가지 격리 접근 방식의 차이로부터 단위 테스트를 바라보는 두 개의 주요 학파, 런던파와 고전파가 형성되었습니다. 두 학파의 가장 근본적인 차이는 테스트 대상인 '단위(Unit)'를 어떻게 정의하고, 그 단위의 의존성을 어떻게 다루는지에 있습니다. 이 차이를 이해하는 것은 우리가 작성할 테스트의 스타일과 구조를 결정하는 첫걸음입니다.

런던파는 '단위'를 철저하게 클래스 하나로 간주합니다. 이 관점에서 단위 테스트의 목적은 개별 클래스의 동작을 고립된 환경에서 검증하는 것입니다. 따라서 테스트 대상 클래스가 의존하는 다른 모든 클래스는 테스트 대역(Test Double)으로 대체해야 한다는 원칙을 고수합니다.

반면에 고전파는 '단위'를 특정 기능 또는 동작의 단위로 좀 더 넓게 봅니다. 이 단위는 하나의 클래스일 수도 있지만, 여러 클래스가 협력하여 하나의 논리적인 기능을 수행하는 객체 그래프 전체가 될 수도 있습니다. 고전파는 메모리 위에서 안정적으로 실행되는 의존 객체까지 굳이 가짜 객체로 대체할 필요는 없다고 보며, 오직 데이터베이스나 외부 API처럼 불안정하고 실행 속도를 저해하는 '프로세스 외부 의존성(Out-of-process dependency)'만을 테스트 대역으로 대체하는 것을 선호합니다.

### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

두 학파가 의존성을 다루는 방식을 구체적인 예를 통해 살펴보겠습니다. 고객의 이메일 주소를 변경하고, 변경 사항을 데이터베이스에 저장하는 기능을 테스트한다고 가정해 봅시다. 이 기능은 UserController와 UserService, 그리고 데이터베이스와 통신하는 UserRepository라는 세 개의 클래스로 구성되어 있습니다.

**런던파의 접근 방식**

런던파 스타일로 이 기능을 테스트한다면, 각 클래스를 개별적으로 테스트합니다. 예를 들어, UserService를 테스트할 때는 UserService가 의존하는 UserRepository를 목(Mock) 객체로 만듭니다. 그리고 UserService의 이메일 변경 메서드를 호출했을 때, 이 목 객체의 특정 메서드(예: save())가 정확한 인자와 함께 호출되었는지를 검증합니다. 즉, UserService가 UserRepository와 '올바르게 상호작용하는지'를 확인하는 것입니다. UserController를 테스트할 때도 마찬가지로 UserService를 목으로 대체하여 테스트를 진행합니다. 이 방식은 각 클래스의 책임이 무엇인지를 명확하게 검증하는 데 초점을 맞춥니다.

**고전파의 접근 방식**

고전파 스타일로 같은 기능을 테스트한다면, UserController에서 시작하여 실제 UserService 인스턴스를 사용합니다. UserService 역시 실제 객체로 생성됩니다. 하지만 UserService가 의존하는 UserRepository는 실제 데이터베이스와 통신하므로, 이는 테스트의 속도를 저해하고 외부 환경에 의존하게 만드는 불안정한 요소입니다. 따라서 고전파는 이 UserRepository 인터페이스에 대해서만 테스트 대역(주로 실제 동작을 흉내 내는 가짜 객체인 스텁(Stub)이나 페이크(Fake))을 사용합니다. 그리고 테스트는 UserController의 메서드를 호출한 후, 최종적으로 시스템의 상태가 기대하는 대로 변경되었는지(예: 사용자 객체의 이메일 속성이 새로운 값으로 바뀌었는지)를 검증합니다. 이 방식은 개별 클래스의 상호작용보다는 여러 클래스가 협력하여 만들어내는 최종 '결과'에 집중합니다.

## 2.3 고전파와 런던파 비교

고전파와 런던파는 단위 테스트라는 같은 목표를 추구하지만, 그 과정에서 서로 다른 가치에 우선순위를 둡니다. 런던파는 버그 위치의 빠른 파악과 개별 클래스의 역할 분리를, 고전파는 리팩터링에 대한 내성과 실제에 가까운 시나리오 검증을 더 중요하게 생각합니다. 이러한 철학의 차이는 실제 테스트 코드 작성과 유지보수 과정에서 구체적인 장단점으로 나타납니다.

### 2.3.1 한 번에 한 클래스만 테스트하기

런던파의 가장 큰 특징은 테스트 대상을 철저하게 클래스 하나로 고립시키는 것입니다. 이 접근법은 테스트의 범위를 매우 좁고 명확하게 만들어 줍니다. 개발자는 오직 테스트 대상 클래스의 내부 로직과, 그 클래스가 직접 호출하는 협력 객체의 메서드가 무엇인지만 신경 쓰면 됩니다. 협력 객체의 내부에서 어떤 일이 일어나는지는 전혀 고려할 필요가 없으므로, 복잡한 시스템의 일부를 이해하고 테스트하는 데 드는 인지적 부하가 줄어듭니다.

하지만 이 방식은 중요한 단점을 가집니다. 테스트가 테스트 대상 클래스의 내부 구현, 특히 '어떻게' 협력하는지에 강하게 결합된다는 점입니다. 만약 기능적인 변경 없이 내부적인 리팩터링을 통해 협력 객체를 호출하는 방식만 바꾸어도 테스트는 실패하게 됩니다. 예를 들어, UserService가 UserRepository의 save 메서드 대신 update 메서드를 호출하도록 수정하면, 최종 결과는 같더라도 기존 save 메서드 호출을 기대하던 테스트는 깨지고 맙니다. 이는 실제 버그가 없음에도 테스트를 수정해야 하는 '거짓 양성'을 유발하여 테스트 스위트 전체의 신뢰도를 떨어뜨리고 유지보수 비용을 증가시킵니다.

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

고전파는 이와 대조적으로 기능적으로 연관된 여러 클래스를 하나의 단위로 묶어 테스트합니다. 앞선 예에서 고전파 테스트는 UserController에서 시작해 실제 UserService 객체를 거쳐 UserRepository의 테스트 대역에 도달하는 전체 흐름을 검증 대상으로 삼습니다. 이렇게 하면 개별 클래스 간의 상호작용 방식이 바뀌더라도 최종 결과에만 영향이 없다면 테스트는 여전히 성공합니다. UserService가 UserRepository의 save를 쓰든 update를 쓰든, 결과적으로 사용자의 이메일이 올바르게 변경되었는지만 확인하기 때문입니다.

이러한 접근 방식은 리팩터링에 대한 내성이 매우 강하다는 결정적인 장점을 가집니다. 개발자는 테스트가 깨질 걱정 없이 내부 코드 구조를 자유롭게 개선할 수 있습니다. 하지만 단점도 존재합니다. 테스트가 실패했을 때, 그 원인이 UserController에 있는지 UserService에 있는지 즉시 알기 어렵다는 것입니다. 여러 클래스가 함께 동작하므로 실패의 원인이 되는 지점을 찾기 위해 약간의 디버깅 과정이 추가로 필요할 수 있습니다. 또한, 테스트를 준비하는 과정에서 여러 클래스의 상태를 설정해야 하므로 상대적으로 복잡하게 느껴질 수도 있습니다.

### 2.3.3 버그 위치 정확히 찾아내기

버그 위치를 정확히 찾아내는 능력은 런던파가 가장 내세우는 장점입니다. 테스트가 오직 하나의 실제 클래스와 여러 개의 목(Mock)으로만 구성되므로, 테스트가 실패했다면 그 원인은 해당 실제 클래스 내부에 있을 수밖에 없습니다. 이는 개발자가 버그의 원인을 찾는 데 드는 시간을 극적으로 줄여줍니다.

이에 대해 고전파는 버그 위치를 정확히 찾아내는 것이 이론만큼 실무에서 중요하지는 않다고 주장합니다. 잘 작성된 고전파 테스트는 '사용자 이메일 변경 기능'처럼 매우 구체적인 시나리오를 대상으로 합니다. 따라서 테스트가 실패하면 디버깅해야 할 범위가 이미 상당히 좁혀져 있습니다. 또한 최신 개발 환경의 디버거는 실패 지점부터 역으로 코드를 추적하는 과정을 매우 효율적으로 지원합니다. 고전파 개발자들은 버그 위치를 찾는 데 몇 분을 더 쓰는 대신, 리팩터링 시 깨지지 않는 견고한 테스트를 통해 장기적인 유지보수 비용을 아끼는 것이 더 현명한 타협이라고 생각합니다.

### 2.3.4 고전파와 런던파 사이의 다른 차이점

두 학파는 테스트 주도 개발(TDD)을 수행하는 흐름에서도 차이를 보입니다. 런던파 스타일은 컨트롤러부터 시작해 서비스, 리포지터리 순으로 계층을 따라 내려가며 개발하는 '외부에서 안으로(Outside-In)' 방식에 자연스럽게 어울립니다. 상위 계층을 테스트하며 필요한 하위 계층의 인터페이스(역할)를 정의하고 목으로 만든 뒤, 다시 그 하위 계층을 구현하는 방식으로 개발을 진행할 수 있습니다.

또한 런던파 테스트는 본질적으로 '상호작용 테스트(Interaction Testing)'에 가깝습니다. 테스트의 검증 단계는 주로 특정 메서드가 올바른 인자와 함께 정확한 횟수만큼 호출되었는지를 확인하는 데 집중됩니다. 반면 고전파 테스트는 '상태 기반 테스트(State-based Testing)'에 가깝습니다. 특정 동작을 실행한 후, 시스템의 상태나 반환된 값이 기대하는 것과 같은지를 검증하는 것이 주된 목적입니다. 이 차이점은 테스트 코드의 검증(Assertion) 구절을 어떻게 작성해야 하는지에 대한 직접적인 지침이 됩니다.

## 2.4 두 분파의 통합 테스트

단위 테스트의 정의가 두 학파 간에 다르듯이, 통합 테스트(Integration Test)를 바라보는 관점 역시 다릅니다. 이는 각 학파가 무엇을 '단위'로 보고 무엇을 '격리'해야 할 대상으로 보는지에 대한 근본적인 시각차에서 비롯됩니다.

고전파 개발자에게 통합 테스트는 명확한 경계를 가집니다. 이들에게 통합 테스트란, 개발자가 제어할 수 없는 외부 시스템, 즉 프로세스 외부 의존성(예: 데이터베이스, 메시지 큐, 외부 API)과 실제 연동하여 수행하는 테스트를 의미합니다. 고전파 단위 테스트에서는 이런 외부 의존성을 테스트 대역으로 대체하여 테스트의 안정성과 속도를 확보했습니다. 반면 통합 테스트는 바로 이 테스트 대역으로 대체했던 부분들이 실제 시스템과 올바르게 연동되는지를 검증하는 역할을 담당합니다. 즉, 내 코드와 외부 시스템 사이의 통합 지점을 확인하는 테스트입니다.

런던파 개발자에게 통합 테스트의 범위는 훨씬 넓습니다. 런던파의 단위 테스트는 오직 클래스 하나만을 대상으로 하므로, 둘 이상의 실제 클래스가 협력하는 모든 테스트는 통합 테스트로 간주됩니다. 예를 들어, 실제 UserController 객체와 실제 UserService 객체를 함께 사용하여 테스트한다면, 비록 UserRepository를 목으로 대체했더라도 런던파의 관점에서는 이미 통합 테스트를 수행하고 있는 것입니다. 이처럼 고전파 개발자가 단위 테스트라고 부르는 많은 테스트가 런던파의 관점에서는 이미 통합 테스트에 해당합니다.

이러한 정의의 차이 때문에 두 학파 간의 대화에는 종종 오해가 발생하곤 합니다. 하지만 이 책에서는 실용적인 관점을 유지하기 위해, 일반적으로 널리 통용되는 고전파의 정의를 따를 것입니다. 즉, 통합 테스트는 실제 데이터베이스나 메시지 버스와 같이 프로세스 외부의 공유 의존성과 연동하여 실행하는 테스트로 정의하고 논의를 이어가겠습니다.

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

통합 테스트의 가장 광범위한 형태는 엔드 투 엔드 테스트(End-to-End Test)입니다. 이 테스트는 시스템을 사용자 관점에서 검증하는 것을 목표로 하며, 시스템의 모든 구성 요소를 실제 운영 환경과 거의 동일한 상태로 통합하여 테스트를 수행합니다.

엔드 투 엔드 테스트는 일반적으로 API 엔드포인트를 호출하는 것으로 시작하여, 비즈니스 로직을 처리하는 서비스 계층과 도메인 모델, 데이터베이스에 접근하는 리포지터리 계층을 모두 거쳐 최종적으로 데이터베이스에 데이터가 올바르게 저장되거나 수정되는지까지 확인하는 전체 과정을 포함합니다. 즉, 사용자의 요청이 시스템의 시작부터 끝까지 아무런 문제 없이 올바르게 처리되는지를 검증하는 것입니다.

이 테스트는 우리 시스템이 전체적으로 잘 동작한다는 가장 강력한 증거를 제공합니다. 하지만 모든 구성 요소를 실제로 동작시키기 때문에 실행 속도가 매우 느리고, 테스트 환경을 구축하고 유지하는 비용이 비쌉니다. 또한 테스트가 실패했을 때, 그 원인이 수많은 구성 요소 중 어디에 있는지 파악하기가 매우 어렵다는 단점이 있습니다. 따라서 엔드 투 엔드 테스트는 전체 테스트 스위트에서 가장 적은 비중을 차지해야 하며, 사용자의 핵심적인 사용 시나리오(Happy Path)를 검증하는 데 주로 사용됩니다.
