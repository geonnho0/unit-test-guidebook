데이터베이스는 대부분의 비즈니스 애플리케이션에서 가장 중요하고 핵심적인 '관리 의존성'이다. 애플리케이션의 모든 중요한 상태는 결국 데이터베이스에 저장되고, 비즈니스 로직은 이 데이터를 기반으로 동작한다. 따라서 우리 코드와 데이터베이스 간의 통합이 원활하게 이루어지는지 검증하는 것은 통합 테스트의 가장 중요한 목표 중 하나이다.

하지만 데이터베이스 테스트는 간단하지 않다. 데이터베이스는 상태를 가지는(stateful) 시스템이며, 여러 테스트가 동일한 데이터베이스 인스턴스에 접근할 때 서로에게 영향을 줄 수 있다. 또한, 테스트 실행 전후로 데이터를 깨끗하게 유지하고, 테스트 실행 속도를 관리하는 등의 여러 가지 문제를 해결해야 한다.

이 장에서는 이러한 데이터베이스 테스트의 과제들을 해결하기 위한 실용적인 전제 조건과 모범 사례들을 다룬다. 형상 관리에 데이터베이스 스키마를 포함하는 것부터 시작하여, 테스트 데이터의 생명주기를 관리하는 방법, 그리고 테스트 코드의 재사용성을 높이는 전략까지, 신뢰할 수 있고 유지보수 가능한 데이터베이스 통합 테스트를 구축하는 데 필요한 모든 것을 알아볼 것이다.

## 10.1 데이터베이스 테스트를 위한 전제 조건

효과적인 데이터베이스 테스트를 수행하기 위해서는 먼저 몇 가지 중요한 인프라와 프로세스가 갖춰져 있어야 한다. 이러한 전제 조건들은 모든 개발자가 일관된 환경에서 안정적으로 테스트를 실행할 수 있도록 보장하는 기반이 된다.

### 10.1.1 데이터베이스를 형상 관리 시스템에 유지

애플리케이션 코드와 마찬가지로, **데이터베이스 스키마(Schema) 역시 Git과 같은 형상 관리 시스템(VCS, Version Control System)에서 코드로 관리되어야 한다.** 데이터베이스 스키마는 테이블 구조, 인덱스, 뷰, 제약 조건 등을 정의하는 모든 DDL(Data Definition Language) 스크립트를 포함한다.

데이터베이스 스키마를 코드로 관리하면 다음과 같은 장점이 있다.

* **변경 이력 추적**: 누가, 언제, 왜 스키마를 변경했는지 모든 이력을 추적할 수 있다.
* **코드 리뷰**: 스키마 변경 역시 애플리케이션 코드와 동일하게 코드 리뷰 프로세스를 거칠 수 있어, 잠재적인 문제를 사전에 발견할 수 있다.
* **재현 가능성**: 어떤 버전의 코드에서도 해당 버전에 맞는 데이터베이스 스키마를 정확하게 재현할 수 있다. 이는 새로운 개발자가 프로젝트에 참여하거나, CI 서버에서 테스트 환경을 구축할 때 매우 중요하다.

Flyway나 Liquibase와 같은 데이터베이스 마이그레이션 도구를 사용하는 것이 스키마를 코드로 관리하는 가장 좋은 방법이다. 이 도구들은 스키마 변경 사항을 버전이 매겨진 SQL 스크립트 파일로 관리하게 해주며, 애플리케이션 실행 시 현재 데이터베이스의 버전과 코드의 버전을 비교하여 필요한 스키마 변경을 자동으로 적용해 준다.

### 10.1.2 참조 데이터도 데이터베이스 스키마다

애플리케이션이 동작하기 위해 필요한 초기 데이터, 즉 **참조 데이터(Reference Data)** 역시 데이터베이스 스키마의 일부로 간주하고 형상 관리 시스템에서 함께 관리해야 한다. 참조 데이터는 예를 들어, 국가 코드 목록, 상품 카테고리 목록, 기본 사용자 역할(Admin, User 등)과 같이 애플리케이션 운영에 필수적인 기초 데이터를 말한다.

이러한 참조 데이터가 없다면 애플리케이션은 정상적으로 동작하지 못할 수 있다. 따라서 데이터베이스 마이그레이션 도구를 사용하여 스키마를 생성(DDL)한 직후, 이러한 참조 데이터를 삽입(DML)하는 마이그레이션 스크립트도 함께 실행되도록 구성해야 한다. 이렇게 함으로써 어떤 환경에서든 애플리케이션이 동작할 수 있는 최소한의 완전한 데이터베이스 상태를 보장할 수 있다.

### 10.1.3 모든 개발자를 위한 별도의 데이터베이스 인스턴스

데이터베이스 테스트의 핵심 원칙 중 하나는 **테스트 격리(Test Isolation)**이다. 각 테스트는 다른 테스트의 결과에 영향을 주어서는 안 되며, 다른 개발자의 작업과도 완전히 격리되어야 한다.

이를 위한 가장 확실한 방법은 **모든 개발자와 모든 CI 빌드 작업이 자신만의 독립적인 데이터베이스 인스턴스를 사용하도록 하는 것**이다. 여러 개발자가 하나의 공유된 개발용 데이터베이스를 함께 사용하는 것은 최악의 안티 패턴이다. 한 개발자가 테스트를 위해 데이터를 수정하거나 삭제하는 순간, 다른 개발자의 테스트가 예기치 않게 실패할 수 있기 때문이다.

오늘날에는 Docker와 같은 컨테이너 기술 덕분에 이러한 격리된 환경을 구축하는 것이 매우 쉬워졌다. 8장에서 본 Testcontainers 라이브러리는 테스트 코드를 실행할 때마다 매번 새로운 데이터베이스 컨테이너를 동적으로 생성하고, 테스트가 끝나면 자동으로 제거해 줌으로써 완벽한 격리를 보장한다. 모든 개발팀은 이러한 방식을 표준으로 채택하여 안정적인 테스트 환경을 구축해야 한다.

### 10.1.4 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포

데이터베이스 스키마를 배포하는 방식은 크게 두 가지로 나눌 수 있다.

* **상태 기반 배포(State-based deployment)**: 원하는 최종 스키마의 '상태'를 정의한 스크립트를 준비한다. 배포 도구는 현재 데이터베이스의 스키마와 목표 스키마의 상태를 비교하여, 그 차이를 없애는 변경 스크립트를 동적으로 생성하고 실행한다.
* **마이그레이션 기반 배포(Migration-based deployment)**: 스키마 변경 사항을 시간 순서대로 버전이 매겨진 마이그레이션 스크립트 파일들로 기록한다. 배포 도구는 현재 데이터베이스에 적용된 마지막 마이그레이션 버전과 코드에 있는 최신 버전을 비교하여, 아직 적용되지 않은 모든 마이그레이션 스크립트를 순서대로 실행한다.

Flyway와 Liquibase는 대표적인 마이그레이션 기반 배포 도구이다. **테스트 자동화와 CI/CD 환경에서는 마이그레이션 기반 배포 방식이 훨씬 더 예측 가능하고 안정적이므로 강력하게 권장된다.** 이 방식은 모든 스키마 변경 과정이 명시적인 코드로 기록되어 있어 추적과 재현이 용이하며, 데이터 손실의 위험 없이 안전하게 스키마를 점진적으로 발전시켜 나갈 수 있다. 통합 테스트 환경을 구축할 때도, 마이그레이션 기반 도구를 사용하면 어떤 버전의 코드에서도 항상 올바른 데이터베이스 스키마를 일관되게 생성할 수 있다.

## 10.2 데이터베이스 트랜잭션 관리

데이터베이스 테스트에서 테스트 격리를 유지하는 또 다른 중요한 기술은 트랜잭션(Transaction)을 올바르게 관리하는 것이다. 각 테스트가 독립적으로 실행되고 서로의 데이터에 영향을 미치지 않도록 하려면, 테스트 중에 발생한 모든 데이터 변경 사항이 테스트가 끝난 후에는 원래 상태로 돌아가야 한다. 이를 달성하기 위한 가장 효과적인 방법은 각 테스트를 별도의 트랜잭션 안에서 실행하고, 테스트가 끝나면 해당 트랜잭션을 롤백(Rollback)하는 것이다.

### 10.2.1 제품 코드에서 데이터베이스 트랜잭션 관리하기

먼저 제품 코드의 트랜잭션 관리를 이해해야 한다. 스프링 프레임워크를 사용하는 경우, 우리는 보통 `@Transactional` 어노테이션을 사용하여 선언적으로 트랜잭션을 관리한다. 서비스 계층의 public 메서드에 `@Transactional`을 붙이면, 스프링은 해당 메서드가 시작될 때 트랜잭션을 시작하고, 메서드가 성공적으로 완료되면 트랜잭션을 커밋(Commit)하며, 예외가 발생하면 롤백한다.

```java
@Service
public class UserService {
    @Transactional // 이 메서드는 하나의 트랜잭션으로 묶인다.
    public void changeEmail(int userId, String newEmail) {
        // ... 데이터베이스 읽기 및 쓰기 작업 ...
    } // 메서드가 끝나면 변경 사항이 커밋된다.
}
```

이 방식의 핵심은 **트랜잭션의 경계를 비즈니스 작업의 단위와 일치시키는 것**이다. '사용자 이메일 변경'이라는 하나의 논리적인 작업이 원자적으로(atomically) 실행되도록 보장하는 것이다.

### 10.2.2 통합 테스트에서 데이터베이스 트랜잭션 관리하기

통합 테스트에서도 `@Transactional` 어노테이션을 매우 유용하게 사용할 수 있다. 테스트 클래스나 테스트 메서드에 `@Transactional`을 붙이면, 스프링 테스트 컨텍스트는 기본적으로 각 테스트가 끝난 후 트랜잭션을 **자동으로 롤백**하도록 동작한다.

```java
@SpringBootTest
@Transactional // 이 클래스의 모든 테스트는 끝난 후 롤백된다.
class UserServiceIntegrationTest {

    @Autowired
    private UserService sut;

    @Autowired
    private UserRepository userRepository;

    @Test
    void changeEmail_should_change_user_email() {
        // Arrange
        // 이 테스트를 위해 데이터를 저장한다.
        User user = userRepository.save(new User("test@email.com"));

        // Act
        sut.changeEmail(user.getId(), "new@email.com");

        // Assert
        // DB에서 다시 조회하여 검증하는 로직은 여기서 의미가 없다.
        // 왜냐하면 아직 트랜잭션이 커밋되지 않았기 때문이다.
        // (실제로는 같은 트랜잭션 내에 있으므로 1차 캐시에서 조회되어 검증이 될 수는 있다)
    } 
    // 테스트 메서드가 끝나면, 위에서 저장하고 수정한 모든 내용은 롤백된다.
    // 따라서 다음 테스트는 깨끗한 상태의 데이터베이스에서 시작할 수 있다.
}
```

이 자동 롤백 기능은 매우 강력하다. 각 테스트가 독립성을 완벽하게 유지할 수 있게 해주며, 테스트 실행 후 데이터를 수동으로 정리하는 번거로운 과정을 없애준다. 이를 통해 우리는 데이터베이스 상태에 대해 걱정할 필요 없이 테스트 로직 자체에만 집중할 수 있다.

다만 한 가지 주의할 점이 있다. `@Transactional` 테스트는 기본적으로 롤백되므로, 테스트 메서드 안에서 수행한 작업은 실제 데이터베이스에 영구적으로 반영되지 않는다. 따라서 테스트 안에서 데이터를 변경한 뒤, 그 변경 사항을 확인하기 위해 리포지터리로 다시 데이터를 조회하는 검증 방식은 트랜잭션 격리 수준이나 ORM의 1차 캐시 동작 방식에 따라 예상과 다르게 동작할 수 있다.

이러한 이유로, 어떤 개발자들은 테스트가 실제 운영 환경과 최대한 동일하게 동작해야 한다고 주장하며 자동 롤백 기능 대신, 각 테스트 실행 전에 수동으로 데이터베이스를 초기화하는 방식(예: SQL 스크립트로 모든 테이블을 TRUNCATE)을 선호하기도 한다. 이 방식은 테스트가 실제 커밋 과정을 포함하게 되므로 신뢰도가 더 높다고 볼 수 있지만, 매번 데이터를 지우고 다시 생성하는 데 시간이 더 오래 걸릴 수 있다.

두 방식 모두 장단점이 있으므로 팀의 상황과 철학에 맞는 전략을 선택하면 된다. 하지만 대부분의 경우, `@Transactional`이 제공하는 자동 롤백 기능은 속도와 편의성 면에서 큰 이점을 제공하며, 통합 테스트를 작성하는 데 매우 효과적인 표준 방식이다. 만약 실제 커밋 후의 동작을 꼭 테스트해야 하는 특정 시나리오가 있다면, 해당 테스트 메서드에만 `@Commit` 어노테이션을 추가하여 기본 롤백 동작을 재정의할 수도 있다.

## 10.3 테스트 데이터 생명 주기

데이터베이스 통합 테스트를 작성할 때 가장 어려운 부분 중 하나는 바로 테스트 데이터를 관리하는 것이다. 각 테스트는 자신만의 격리된 데이터 환경이 필요하며, 다른 테스트나 병렬 실행에 의해 오염되어서는 안 된다. 테스트 데이터의 생명주기를 어떻게 관리할 것인가는 테스트 스위트의 안정성과 속도에 직접적인 영향을 미친다.

### 10.3.1 병렬 테스트 실행과 순차적 테스트 실행

테스트 스위트의 크기가 커지면 전체 실행 시간을 줄이기 위해 테스트를 병렬로 실행하는 것을 고려하게 된다. 하지만 데이터베이스를 사용하는 통합 테스트는 상태를 공유하기 때문에 병렬 실행 시 문제가 발생하기 매우 쉽다.

만약 여러 테스트가 동시에 같은 데이터베이스 테이블에 접근하여 데이터를 추가, 수정, 삭제한다면 서로의 작업을 방해하여 예측 불가능한 결과를 낳을 것이다. 예를 들어, `testA`는 사용자 수가 5명인 상황을 가정하고 실행 중인데, 동시에 실행된 `testB`가 사용자를 한 명 더 추가해버리면 `testA`는 실패하게 된다.

이 문제를 해결하는 가장 확실한 방법은 10.1.3절에서 강조했듯이, **각 테스트 실행(또는 각 테스트 스레드)마다 완전히 독립된 데이터베이스 인스턴스를 제공하는 것**이다. Testcontainers와 같은 도구를 사용하면 이를 쉽게 구현할 수 있다.

만약 이것이 불가능하고 단일 데이터베이스 인스턴스를 공유해야만 하는 상황이라면, 데이터베이스 통합 테스트는 **반드시 순차적으로 실행**해야 한다. 그리고 앞서 10.2.2절에서 설명한 트랜잭션 롤백 전략을 사용하여 각 테스트가 끝난 후 자신의 변경 사항을 깨끗하게 정리하도록 보장해야 한다.

### 10.3.2 테스트 실행 간 데이터 정리

테스트 격리를 보장하기 위한 핵심은 각 테스트가 끝난 후에는 데이터베이스를 테스트 실행 전의 깨끗한 상태로 되돌려 놓는 것이다. 여기에는 몇 가지 전략이 있다.

1. **매 테스트 후 롤백 (가장 권장)**: 앞서 설명했듯이 `@Transactional`을 사용하여 각 테스트를 트랜잭션으로 묶고 자동으로 롤백하는 방식이다. 가장 빠르고 간편하며, 대부분의 경우에 가장 좋은 전략이다.
2. **매 테스트 후 테이블 비우기(Truncate)**: `@Transactional`을 사용하지 않고 실제 커밋을 테스트하고 싶다면, 각 테스트 메서드가 끝난 후(`@AfterEach`)에 모든 관련 테이블의 데이터를 삭제하는 SQL `TRUNCATE` 스크립트를 실행할 수 있다. 이 방식은 롤백보다 약간 느리지만, 실제 커밋 동작을 포함하므로 더 높은 신뢰도를 제공한다.
3. **매 테스트 클래스 실행 후 정리**: 테스트 메서드 단위가 아니라, 테스트 클래스 단위로 데이터를 정리할 수도 있다. `@AfterAll` 블록에서 데이터를 정리하는 방식이다. 이는 테스트 클래스 내의 메서드들이 동일한 초기 데이터를 공유하여 순차적으로 실행될 때 유용할 수 있지만, 테스트 간의 독립성을 해칠 위험이 있어 신중하게 사용해야 한다.

어떤 전략을 사용하든, 중요한 것은 **다음 테스트가 이전 테스트의 '쓰레기 데이터' 때문에 실패하는 일이 없도록 보장하는 것**이다.

### 10.3.3 인메모리 데이터베이스 피하기

이것은 8.2.3절에서 강조했던 내용을 다시 한번 반복하는 것이다. H2와 같은 인메모리 데이터베이스를 실제 운영 환경의 데이터베이스(예: PostgreSQL, MySQL, Oracle) 대신 사용하는 것은 매력적인 유혹이지만, 이는 **매우 위험한 안티 패턴**이다.

인메모리 데이터베이스는 결코 실제 데이터베이스를 완벽하게 대체할 수 없다. 각 데이터베이스 벤더는 고유의 데이터 타입, 함수, SQL 문법, 트랜잭션 격리 수준 동작 방식을 가지고 있으며, 인메모리 데이터베이스는 이러한 미묘한 차이점들을 모두 흉내 내지 못한다.

인메모리 데이터베이스에서 통과한 테스트는 실제 운영 환경에서 실패할 수 있다는 '거짓 양성'의 위험을 항상 내포하고 있다. 이는 통합 테스트를 통해 얻고자 하는 '신뢰도'라는 가장 중요한 가치를 훼손하는 것이다.

오늘날 Testcontainers와 Docker를 사용하면 실제 데이터베이스를 테스트에 사용하는 것이 그 어느 때보다 쉬워졌다. 약간의 초기 설정 비용을 감수하더라도, 반드시 **운영 환경과 동일한 종류의 데이터베이스를 사용하여 테스트하라.** 이것이야말로 데이터베이스 테스트의 신뢰도를 보장하는 유일한 길이다.

## 10.4 테스트 구절에서 코드 재사용하기

데이터베이스 통합 테스트를 작성하다 보면, 여러 테스트에서 유사한 데이터를 준비(Arrange)하고, 비슷한 동작을 실행(Act)하며, 유사한 결과를 검증(Assert)하는 코드가 반복적으로 나타나는 것을 발견하게 된다. 이러한 코드 중복은 테스트 스위트의 유지보수성을 저해하는 주요 원인이다. 3.3절에서 단위 테스트의 픽스처 재사용 전략을 논의했던 것처럼, 통합 테스트에서도 AAA 패턴의 각 구절에서 코드를 효과적으로 재사용하는 방법을 고민해야 한다.

### 10.4.1 준비 구절에서 코드 재사용하기

준비(Arrange) 구절의 목표는 테스트 시나리오에 필요한 초기 데이터 상태를 만드는 것이다. 여러 테스트에서 동일한 종류의 엔티티(예: 사용자, 상품)를 생성해야 할 때, 매번 `new User(...)`, `userRepository.save(...)` 와 같은 코드를 반복해서 작성하는 것은 비효율적이다.

이러한 중복을 제거하는 가장 좋은 방법은 **테스트 데이터 빌더(Test Data Builder)**나 **팩토리 메서드(Factory Method)** 패턴을 활용하는 것이다. 이 패턴들은 테스트에 필요한 객체 생성을 도와주는 헬퍼 클래스나 메서드를 만드는 것을 의미한다.

**팩토리 메서드를 사용한 예시**

테스트 클래스 내에 엔티티를 생성하고 데이터베이스에 저장까지 해주는 비공개 팩토리 메서드를 만들 수 있다.

```java
@SpringBootTest
@Transactional
class ProductServiceIntegrationTest {

    @Autowired
    private ProductRepository productRepository;
    
    // ...

    @Test
    void testSomethingWithProduct() {
        // Arrange
        Product product = createAndSaveProduct("테스트 상품", 10000);
        // ...
    }

    // 팩토리 메서드
    private Product createAndSaveProduct(String name, long price) {
        Product product = new Product(name, price);
        return productRepository.save(product);
    }
}
```

이 방식은 간단하고 직관적이지만, 생성해야 할 데이터의 종류가 많아지면 테스트 클래스가 비대해질 수 있다.

**테스트 데이터 빌더를 사용한 예시**

더 발전된 방법은 테스트 데이터 생성을 전담하는 별도의 빌더 클래스를 만드는 것이다. 빌더 패턴을 사용하면 기본값이 설정된 객체를 쉽게 만들면서도, 특정 테스트에 필요한 속성만 선택적으로 변경할 수 있어 매우 유연하다.

```java
// 빌더 클래스
public class ProductBuilder {
    private String name = "기본 상품";
    private long price = 1000;

    public ProductBuilder withName(String name) {
        this.name = name;
        return this;
    }

    public ProductBuilder withPrice(long price) {
        this.price = price;
        return this;
    }

    public Product build() {
        return new Product(name, price);
    }

    public Product persist(ProductRepository repository) {
        return repository.save(build());
    }
}

// 테스트 코드
@Test
void testWithHighPriceProduct() {
    // Arrange
    Product product = new ProductBuilder()
                            .withName("고가 상품")
                            .withPrice(100000)
                            .persist(productRepository);
    // ...
}
```

테스트 데이터 빌더는 테스트 코드의 가독성을 크게 향상시키고, 테스트 데이터 생성 로직을 한곳에 모아 유지보수하기 쉽게 만들어준다.

### 10.4.2 실행 구절에서 코드 재사용하기

실행(Act) 구절은 일반적으로 SUT의 메서드를 호출하는 단 한 줄의 코드로 이루어지므로, 코드 재사용의 필요성이 상대적으로 적다. 하지만 만약 여러 테스트에서 동일한 서비스 메서드를 호출해야 하고, 그 호출 방식이 복잡하다면 이를 재사용하는 것을 고려해볼 수 있다.

그러나 실행 구절의 코드를 별도의 헬퍼 메서드로 추출하는 것은 신중해야 한다. 이는 테스트의 핵심 동작을 숨겨 가독성을 해칠 수 있기 때문이다. 대부분의 경우, 실행 구절은 각 테스트 메서드 안에 명시적으로 남겨두어 무엇을 테스트하는지 명확히 보여주는 것이 더 낫다.

### 10.4.3 검증 구절에서 코드 재사용하기

검증(Assert) 구절에서는 종종 여러 속성을 확인하는 코드가 반복될 수 있다. 예를 들어, 사용자 생성 기능을 테스트할 때마다 생성된 사용자의 이름, 이메일, 초기 상태, 생성 시간 등이 모두 올바른지 확인해야 할 수 있다.

이러한 반복적인 검증 로직은 **커스텀 검증 메서드(Custom Assertion Method)**나 AssertJ와 같은 라이브러리의 커스텀 Assertion 객체를 만들어 재사용할 수 있다.

**커스텀 검증 헬퍼 메서드를 사용한 예시**

```java
@Test
void createUser_should_create_user_with_default_settings() {
    // ... Arrange, Act ...
    User createdUser = userRepository.findById(...);

    // Assert
    assertUserHasDefaultSettings(createdUser);
}

private void assertUserHasDefaultSettings(User user) {
    assertThat(user.getName()).isEqualTo("Default User");
    assertThat(user.isActive()).isTrue();
    assertThat(user.getPoints()).isZero();
    // ... 등등
}
```

이 방식은 검증 로직을 하나의 메서드로 캡슐화하여 테스트 코드를 간결하게 유지해준다. 또한, `assertUserHasDefaultSettings`라는 메서드 이름 자체가 무엇을 검증하는지 명확하게 알려주는 문서의 역할도 한다.

### 10.4.4 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가

데이터베이스 통합 테스트를 작성할 때 흔히 하는 걱정 중 하나는 테스트 준비를 위해 너무 많은 데이터를 저장하면서 데이터베이스와의 통신이 과도하게 발생하는 것이 아닌가 하는 점이다. 예를 들어, 주문 기능을 테스트하기 위해 먼저 사용자(User), 주소(Address), 상품(Product), 쿠폰(Coupon) 등을 데이터베이스에 저장해야 할 수 있다.

결론부터 말하면, **이는 크게 걱정할 문제가 아니다.**

통합 테스트의 목적 자체가 우리 코드와 데이터베이스 간의 연동을 검증하는 것이다. 테스트 준비 과정에서 리포지터리를 통해 데이터를 저장하는 행위 역시 이 '연동'의 일부이며, 이 과정이 올바르게 동작하는지 확인하는 것 또한 테스트의 중요한 부분이다.

만약 테스트 준비 과정이 너무 복잡하고 많은 데이터를 필요로 한다면, 이는 테스트의 문제라기보다는 **SUT의 설계 문제**일 가능성이 높다. 테스트 대상 메서드가 너무 많은 의존성과 전제 조건을 가지고 있다는 신호일 수 있으므로, 해당 메서드의 책임을 분리하는 리팩터링을 고려해야 한다.

테스트의 성능이 문제가 된다면, 테스트 데이터 준비를 위해 개별적으로 `save()`를 여러 번 호출하는 대신, 여러 엔티티를 한 번에 저장하는 헬퍼 메서드를 만들거나, JDBC를 직접 사용하여 대량의 데이터를 빠르게 삽입하는 방법을 고려해볼 수는 있다. 하지만 테스트의 명확성과 신뢰도를 희생시키면서까지 데이터베이스 호출 횟수를 줄이는 데 집착할 필요는 없다.

## 10.5 데이터베이스 테스트에 대한 일반적인 질문

데이터베이스 테스트를 처음 접하는 개발자들이 자주 묻는 몇 가지 질문에 대해 답하며 이 장을 마무리하겠다.

### 10.5.1 읽기 테스트를 해야 하는가?

"데이터를 변경하지 않고 단순히 조회만 하는 기능도 통합 테스트를 해야 하는가?"라는 질문이다. 예를 들어, `ProductService`의 `findAllProducts()` 메서드가 `productRepository.findAll()`을 호출하여 모든 상품 목록을 반환하는 기능을 테스트해야 할까?

**일반적으로는 그렇다.** 비록 쓰기 작업보다는 덜 중요할 수 있지만, 읽기 테스트 역시 중요한 가치를 가진다.

* **ORM 매핑 검증**: 복잡한 연관 관계 매핑(`@OneToMany`, `@ManyToOne` 등)이나 조회 전략(Fetch Strategy)이 올바르게 설정되었는지 확인하려면, 실제로 데이터를 조회해보는 것이 가장 확실한 방법이다. N+1 문제와 같은 성능 문제를 발견하는 계기가 될 수도 있다.
* **복잡한 조회 쿼리 검증**: JPQL이나 QueryDSL을 사용하여 작성된 복잡한 동적 조회 쿼리(검색 조건, 정렬 순서 등)가 올바른 SQL로 변환되어 문제없이 실행되는지 확인하려면 통합 테스트가 필수적이다.
* **데이터베이스 뷰/함수 검증**: 데이터베이스의 뷰(View)나 특정 함수를 사용하는 읽기 로직이 있다면, 이 역시 실제 데이터베이스와 연동해야만 검증이 가능하다.

물론, 단순히 `repository.findAll()`을 호출하는 것처럼 로직이 없는 경우는 테스트의 우선순위가 낮을 수 있다. 하지만 조금이라도 복잡성이 포함된 읽기 로직이라면, 통합 테스트를 통해 검증하는 것이 시스템의 안정성을 보장하는 길이다.

### 10.5.2 리포지터리 테스트를 해야 하는가?

"스프링 데이터 JPA가 자동으로 생성해주는 리포지터리 인터페이스의 기본 메서드들(`save`, `findById` 등)도 테스트해야 하는가?"라는 질문이다.

**아니오, 그럴 필요 없다.** 스프링 데이터 JPA와 같은 프레임워크가 제공하는 기능은 이미 해당 프레임워크 개발팀에 의해 철저히 테스트되었다고 신뢰해야 한다. 우리가 이 기능들을 다시 테스트하는 것은 프레임워크를 테스트하는 것과 같으며, 이는 시간 낭비이다.

우리가 테스트해야 할 것은 **우리가 직접 작성한 코드**이다. 리포지터리 계층에서 우리가 테스트해야 할 대상은 다음과 같다.

* `@Query` 어노테이션이나 JPQL, QueryDSL 등을 사용하여 **우리가 직접 작성한 커스텀 조회 메서드**.
* 리포지터리 인터페이스에 추가한 `default` 메서드.

이러한 커스텀 쿼리들은 복잡한 비즈니스 로직을 포함할 수 있으며, 오타나 논리적 오류가 발생하기 쉽다. 따라서 이러한 부분은 통합 테스트를 통해 철저히 검증해야 한다. 하지만 프레임워크가 제공하는 기본적인 CRUD 기능에 대한 테스트를 작성하는 데 시간을 낭비해서는 안 된다.

## 10.6 결론

이번 장에서는 데이터베이스 통합 테스트를 성공적으로 수행하기 위한 다양한 전제 조건, 기술, 모범 사례에 대해 알아보았다.

효과적인 데이터베이스 테스트는 **데이터베이스 스키마를 코드로 관리**하고, **모든 개발자에게 격리된 테스트 인스턴스를 제공**하는 것에서부터 시작된다. 테스트 격리를 보장하기 위해 **각 테스트를 별도의 트랜잭션에서 실행하고 롤백**하는 전략이 매우 효과적이며, 신뢰도를 위해 **인메모리 데이터베이스가 아닌 실제 운영 환경과 동일한 종류의 데이터베이스를 사용**하는 것이 무엇보다 중요하다.

또한, **테스트 데이터 빌더**나 **커스텀 검증 메서드**를 사용하여 테스트 코드의 중복을 제거하고 유지보수성을 높이는 방법을 배웠다. 복잡한 읽기 로직이나 우리가 직접 작성한 커스텀 리포지터리 메서드는 통합 테스트의 좋은 대상이지만, 프레임워크가 제공하는 기본 기능을 테스트할 필요는 없다.

데이터베이스 테스트는 설정할 것도 많고 고려할 것도 많아 어렵게 느껴질 수 있다. 하지만 이 장에서 제시된 원칙들을 따르면, 우리 코드와 데이터베이스가 함께 잘 동작한다는 강력한 확신을 주는, 안정적이고 가치 있는 테스트 스위트를 구축할 수 있을 것이다.
