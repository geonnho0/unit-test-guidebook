지금까지 우리는 단위 테스트의 세계를 깊이 있게 탐험했다. 가치 있는 단위 테스트는 외부 의존성으로부터 격리되어 빠르고 안정적으로 실행되며, 코드베이스의 핵심인 도메인 모델의 비즈니스 규칙을 철저히 검증한다. 잘 만들어진 단위 테스트 스위트는 개발자에게 빠른 피드백을 제공하고 자신감 있는 리팩터링을 가능하게 하는 강력한 안전망이다.

하지만 단위 테스트만으로는 소프트웨어의 품질을 완벽하게 보장할 수 없다. 단위 테스트의 가장 큰 특징인 '격리'는 동시에 그것의 가장 큰 한계이기 때문이다. 우리 코드가 아무리 단위 테스트를 완벽하게 통과하더라도, 실제 데이터베이스, 외부 API, 메시지 큐와 같은 다른 시스템과 올바르게 '통합'되어 동작한다는 보장은 어디에도 없다.

이 간극을 메우는 것이 바로 **통합 테스트(Integration Test)**의 역할이다. 통합 테스트는 격리의 벽을 허물고 우리 코드가 외부 시스템과 실제로 소통하는 방식을 검증한다. 이 장에서는 왜 통합 테스트가 필수적인지, 어떤 종류의 외부 의존성을 직접 테스트해야 하는지, 그리고 효과적인 통합 테스트를 어떻게 작성하는지에 대한 기본 원칙을 다룬다.

## 8.1 통합 테스트는 무엇인가?

통합 테스트는 단위 테스트의 경계를 넘어, 두 개 이상의 독립적인 컴포넌트가 함께 연동되는 방식을 검증하는 테스트를 총칭한다. 이 '컴포넌트'의 범위는 매우 넓을 수 있다. 우리 애플리케이션 내부의 여러 클래스 간의 통합일 수도 있고, 우리 애플리케이션과 프로세스 외부의 다른 시스템(데이터베이스, 파일 시스템, 외부 API 등)과의 통합일 수도 있다.

이 책에서는 실용적인 관점에서, 통합 테스트를 **우리 코드가 프로세스 외부 의존성과 실제로 연동하여 동작하는 것을 검증하는 테스트**로 정의하고 논의를 집중할 것이다. 단위 테스트에서는 이 외부 의존성들을 테스트 대역(목, 스텁)으로 대체하여 테스트의 속도와 안정성을 확보했다. 통합 테스트는 바로 그 테스트 대역으로 대체했던 부분들이 실제 시스템과 올바르게 상호작용하는지를 확인하는 역할을 한다.

### 8.1.1 통합 테스트의 역할

단위 테스트가 비즈니스 로직의 정확성을 보장한다면, 통합 테스트는 우리 시스템이 외부 세계와 맺고 있는 **계약(Contract)**이 올바르게 지켜지고 있는지를 보장한다. 예를 들어, 다음과 같은 계약들을 검증한다.

* 우리가 작성한 JPA 엔티티와 리포지터리가 데이터베이스 스키마와 올바르게 매핑되어, 실제 SQL 쿼리가 문제없이 실행되는가?
* 데이터베이스에 특정 형식의 데이터를 저장하고 다시 읽어왔을 때, 데이터의 유실이나 변환 오류는 없는가?
* 외부 결제 서비스 API에 우리가 보내는 요청 메시지의 형식이 그들이 요구하는 명세와 일치하는가?
* 외부 API가 응답으로 보낸 JSON 데이터를 우리 시스템의 객체로 올바르게 역직렬화할 수 있는가?
* 메시지 큐에 메시지를 발행(publish)하고 구독(subscribe)하는 과정이 문제없이 동작하는가?

이러한 문제들은 단위 테스트만으로는 절대 발견할 수 없다. 아무리 단위 테스트가 100% 통과하더라도, 실제 운영 환경에서는 데이터베이스 연결 오류나 API 명세 변경 등으로 인해 시스템이 쉽게 실패할 수 있다. 통합 테스트는 이러한 종류의 버그를 개발 단계에서 미리 발견하여 시스템의 전체적인 안정성을 크게 높여준다.

### 8.1.2 다시 보는 테스트 피라미드

통합 테스트의 역할을 이해하면, 4장에서 보았던 테스트 피라미드 모델을 더 깊이 있게 이해할 수 있다.

* **단위 테스트 (넓은 기반)**: 시스템의 대부분을 차지하는 핵심 비즈니스 로직을 검증한다. 빠르고 안정적이다.
* **통합 테스트 (중간 계층)**: 외부 시스템과의 연동 지점을 검증한다. 단위 테스트보다 느리고 유지보수 비용이 높지만, 단위 테스트가 놓치는 중요한 종류의 버그를 잡아낸다. 단위 테스트보다 그 수가 적어야 한다.
* **엔드 투 엔드 테스트 (좁은 꼭대기)**: 사용자 관점에서 시스템 전체의 흐름을 검증한다. 가장 강력한 신뢰도를 제공하지만 비용이 매우 비싸므로, 핵심적인 시나리오에 대해서만 최소한으로 작성한다.

통합 테스트는 이 피라미드에서 매우 중요한 허리 역할을 담당한다. 단위 테스트의 속도와 안정성, 그리고 엔드 투 엔드 테스트의 신뢰도와 커버리지 사이에서 균형을 맞추는 핵심적인 역할을 수행하는 것이다. 잘 만들어진 통합 테스트 스위트는 엔드 투 엔드 테스트의 수를 줄여주면서도, 단위 테스트만으로는 부족했던 시스템의 신뢰도를 효과적으로 보완해 준다.

### 8.1.3 통합 테스트와 빠른 실패

통합 테스트는 '빠른 실패(Fail Fast)' 원칙을 소프트웨어 개발 프로세스에 적용하는 실질적인 방법이다. 통합 과정에서 발생하는 문제는 개발 주기의 후반부로 갈수록 발견하고 수정하는 비용이 기하급수적으로 증가한다.

만약 통합 테스트 없이 개발을 진행했다고 상상해 보자. 개발자들은 각자의 로컬 환경에서 단위 테스트만 통과시킨 채 코드를 계속해서 통합 브랜치에 푸시할 것이다. 그러다 모든 기능 개발이 끝난 뒤 QA 단계나 실제 배포 후에야 데이터베이스 스키마와 코드가 맞지 않거나, 외부 API 호출 방식이 잘못되었다는 사실을 발견하게 될 수 있다. 이 시점에서 문제를 해결하려면 수많은 코드를 다시 수정하고 테스트해야 하며, 최악의 경우 아키텍처 자체를 변경해야 할 수도 있다.

반면, CI(Continuous Integration) 파이프라인에 통합 테스트가 포함되어 있다면, 개발자가 코드를 푸시할 때마다 자동으로 외부 시스템과의 연동을 검증한다. 만약 누군가의 변경으로 인해 데이터베이스 연동에 문제가 생겼다면, 빌드 과정에서 즉시 테스트가 실패하며 문제를 조기에 알려준다. 이를 통해 개발팀은 버그가 더 큰 문제로 번지기 전에 신속하게 원인을 파악하고 수정할 수 있게 된다.

## 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가

통합 테스트의 목적이 프로세스 외부 의존성과의 연동을 검증하는 것이라면, 어떤 종류의 의존성을 실제 연동하여 테스트하고 어떤 것은 테스트 대역으로 대체해야 하는지 결정하는 기준이 필요하다. 모든 외부 의존성을 무작정 실제 환경과 연동하는 것은 테스트를 너무 느리고 불안정하게 만들 수 있기 때문이다.

5.4.1절에서 잠시 언급했듯이, 우리는 외부 의존성을 크게 **관리 의존성(Managed dependency)**과 **비관리 의존성(Unmanaged dependency)** 두 가지로 나눌 수 있다. 이 구분이 바로 통합 테스트의 범위를 결정하는 핵심 기준이 된다.

### 8.2.1 프로세스 외부 의존성의 두 가지 유형

* **관리 의존성 (테스트 대상)**
  관리 의존성은 우리 애플리케이션 개발팀이 직접 소유하고 제어할 수 있는 외부 시스템을 말한다. 가장 대표적인 예가 바로 애플리케이션의 주 **데이터베이스**이다. 우리는 데이터베이스 스키마를 직접 관리하며, 테스트 환경에 격리된 데이터베이스 인스턴스를 쉽게 생성하고, 테스트 실행 전에 특정 상태로 초기화하며, 테스트가 끝난 후 깨끗하게 정리할 수 있다. 로컬 파일 시스템에 파일을 읽고 쓰는 로직 역시 관리 의존성으로 볼 수 있다.

  **관리 의존성은 통합 테스트의 핵심 대상이다.** 우리 코드와 데이터베이스 스키마 간의 불일치, ORM(Object-Relational Mapping) 설정 오류, SQL 쿼리 문제 등은 매우 흔하게 발생하는 버그 유형이다. 이러한 버그는 오직 실제 데이터베이스(또는 그와 동일한 종류의 데이터베이스)와 직접 연동하는 통합 테스트를 통해서만 확실하게 잡아낼 수 있다. 따라서 데이터베이스와의 통신은 절대 목(Mock)으로 처리해서는 안 되며, 반드시 통합 테스트의 범위에 포함해야 한다.

* **비관리 의존성 (테스트 대역으로 대체)**
  비관리 의존성은 우리가 직접 제어할 수 없는 제3자(third-party) 소유의 외부 시스템을 의미한다. 예를 들면 다음과 같다.
  * 신용카드 결제를 처리하는 외부 결제 게이트웨이(PG) API
  * 이메일이나 SMS를 발송하는 외부 메시징 서비스
  * 주소를 좌표로 변환해주는 외부 지도 서비스 API

  **비관리 의존성은 단위 테스트에서와 마찬가지로 통합 테스트에서도 테스트 대역으로 대체해야 한다.** 그 이유는 명확하다. 첫째, 이 서비스들은 우리 소유가 아니므로 테스트 목적으로 마음대로 상태를 조작하거나 켜고 끌 수 없다. 둘째, 실제 네트워크를 통해 통신하므로 매우 느리고 불안정하다. 외부 서비스의 장애가 우리 테스트의 실패로 이어져서는 안 된다. 셋째, 대부분의 외부 API는 실제 돈과 관련된 호출(결제 등)을 포함하고 있어 테스트 중에 실제 비용이 발생할 수 있다.

  따라서 비관리 의존성과의 경계에 위치한 포트(인터페이스)에 대해서는 목 객체를 사용하여, "우리 시스템이 외부 API의 명세에 맞는 올바른 요청을 보냈는가?"까지만 검증하는 것이 합리적이다.

### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

간혹 하나의 의존성이 관리 의존성과 비관리 의존성의 특징을 모두 가지는 경우가 있다. 예를 들어, 우리 회사의 다른 팀에서 개발하고 운영하는 마이크로서비스 API를 호출해야 한다고 가정해 보자. 이 API는 우리 소유의 자산이라는 점에서는 관리 의존성처럼 보이지만, 우리가 직접 제어할 수 없고 네트워크를 통해 통신해야 한다는 점에서는 비관리 의존성처럼 보인다.

이러한 경우에도 원칙은 동일하다. 우리 테스트 스위치의 안정성과 속도를 해치는 의존성이라면 테스트 대역으로 대체하는 것이 좋다. 다른 팀의 서비스가 장애 상황이거나 배포 중일 때 우리 팀의 테스트가 실패하는 상황은 피해야 한다. 따라서 일반적으로 다른 서비스 API와의 통신은 비관리 의존성으로 간주하고 목으로 처리하는 것이 바람직하다.

대신 두 서비스 간의 실제 연동은 **계약 테스트(Contract Testing)**나 별도의 전용 엔드 투 엔드 테스트 환경을 통해 검증하는 것이 더 효과적인 전략이다. 계약 테스트는 서비스 제공자가 API 명세를 '계약서' 형태로 정의하면, 서비스 소비자가 그 계약서를 바탕으로 자신의 코드를 검증하고, 제공자 역시 자신의 서비스가 계약서를 준수하는지 검증하는 방식으로 진행된다. 이를 통해 두 서비스가 서로 직접 통신하지 않고도 통합의 신뢰성을 확보할 수 있다.

### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?

가장 이상적인 통합 테스트는 실제 운영 환경에서 사용하는 것과 동일한 종류의 데이터베이스(예: PostgreSQL, MySQL)를 사용하는 것이다. Docker와 같은 컨테이너 기술 덕분에 오늘날에는 테스트 실행 시 격리된 데이터베이스 인스턴스를 쉽게 띄우고 제거할 수 있다.

하지만 여러 제약으로 인해 실제 데이터베이스를 테스트에 사용하는 것이 어려운 경우가 있을 수 있다. 이럴 때 많은 개발자가 선택하는 대안이 바로 **인메모리 데이터베이스(In-memory Database)**, 예를 들어 H2이다. 인메모리 데이터베이스는 실행이 매우 빠르고 별도의 설치가 필요 없다는 장점이 있다.

그러나 인메모리 데이터베이스를 사용하는 것은 **상당한 위험**을 내포한다. H2와 같은 인메모리 데이터베이스는 표준 SQL을 대부분 지원하지만, 특정 데이터베이스 벤더(PostgreSQL, Oracle 등)가 제공하는 고유의 함수나 데이터 타입, SQL 문법(dialect)을 완벽하게 흉내 내지는 못한다.

이러한 미묘한 차이 때문에, 인메모리 데이터베이스에서 성공한 테스트가 실제 운영 데이터베이스에서는 실패하는 경우가 발생할 수 있다. 예를 들어, 특정 윈도우 함수나 JSON 관련 함수를 사용하는 쿼리는 H2에서는 동작하지 않거나 다르게 동작할 수 있다.

결론적으로, 인메모리 데이터베이스는 최후의 수단으로만 고려해야 한다. 이는 실제 데이터베이스와의 통합을 검증한다는 통합 테스트의 근본적인 목표를 완전히 충족시키지 못하는 '불완전한' 통합 테스트이다. **테스트의 신뢰도를 최고 수준으로 유지하기 위해서는, 가능한 모든 노력을 기울여 운영 환경과 동일한 종류의 데이터베이스를 테스트에 사용하는 것을 강력히 권장한다.** Docker를 활용한 Testcontainers 라이브러리와 같은 도구들은 이를 매우 쉽게 만들어 준다.

## 8.3 통합 테스트: 예제

이제 실제 코드를 통해 통합 테스트를 어떻게 작성하는지 구체적으로 살펴보자. 우리는 7장에서 리팩터링했던 고객 관리 시스템의 `UserService`를 테스트 대상으로 삼을 것이다. `UserService`는 `UserRepository`와 `CompanyRepository`를 통해 데이터베이스와 통신하고, `MessageBus`를 통해 외부 메시징 시스템과 통신한다.

### 8.3.1 어떤 시나리오를 테스트할까?

단위 테스트가 클래스의 모든 분기(branch)와 엣지 케이스를 다루려 노력하는 것과 달리, 통합 테스트는 그럴 필요가 없다. 이미 핵심 비즈니스 로직의 정확성은 신뢰도 높은 단위 테스트를 통해 충분히 검증되었기 때문이다.

통합 테스트의 주된 목적은 우리 코드와 외부 시스템 간의 '연결'이 잘 되어 있는지를 확인하는 것이다. 따라서 통합 테스트는 주로 시스템의 **해피 패스(happy path)** 시나리오, 즉 가장 일반적이고 성공적인 흐름을 한두 개 검증하는 데 집중하는 것으로 충분하다.

우리가 테스트할 시나리오는 다음과 같다.
"데이터베이스에 특정 사용자와 회사 정보가 주어졌을 때, `UserService.changeEmail`을 호출하면 사용자의 이메일이 성공적으로 변경되고, 회사의 직원 수가 1 증가하며, 변경된 정보가 데이터베이스에 올바르게 저장된다."

이 하나의 시나리오를 통해 우리는 다음의 통합 지점들을 모두 검증할 수 있다.
* `UserRepository`가 사용자를 올바르게 조회하고 저장하는가?
* `CompanyRepository`가 회사를 올바르게 조회하고 저장하는가?
* `User` 및 `Company` 엔티티와 실제 데이터베이스 테이블 간의 ORM 매핑이 올바른가?
* 데이터베이스 트랜잭션이 문제없이 커밋되는가?

### 8.3.2 데이터베이스와 메시지 버스 분류하기

테스트를 작성하기 전에, 의존성을 분류해야 한다.
* **데이터베이스 (`UserRepository`, `CompanyRepository`)**: 이 시스템의 핵심 데이터를 저장하는 우리 소유의 시스템이므로 **관리 의존성**이다. 따라서 실제 데이터베이스와 연동하여 테스트해야 한다.
* **메시지 버스 (`MessageBus`)**: 외부 메시징 시스템과 통신하는 인터페이스이다. 실제 메시지 큐는 외부 시스템이므로 **비관리 의존성**으로 간주하는 것이 합리적이다. 따라서 이 부분은 목(Mock)으로 처리하여, "메시지를 보내라는 요청이 올바르게 전달되었는가?"까지만 확인할 것이다.

### 8.3.3 엔드 투 엔드 테스트는 어떤가?

이 시나리오를 컨트롤러 계층부터 시작하는 엔드 투 엔드 테스트로 검증할 수도 있다. 하지만 그렇게 하면 테스트가 더 복잡해지고, HTTP 관련 설정과 직렬화/역직렬화 로직까지 포함하게 되어 테스트의 범위가 너무 넓어진다.

우리의 목표는 '비즈니스 로직과 데이터베이스 간의 통합'을 검증하는 것이므로, 컨트롤러를 제외하고 비즈니스 로직이 시작되는 `UserService` 계층에서 직접 테스트를 시작하는 것이 더 효율적이고 집중된 접근 방식이다.

### 8.3.4 통합 테스트: 첫 번째 시도

이제 스프링 부트 환경에서 JUnit 5와 Testcontainers를 사용하여 통합 테스트를 작성해 보자. `@SpringBootTest`는 실제 스프링 애플리케이션 컨텍스트를 로드하여 모든 빈(Bean)을 주입받을 수 있게 해주고, Testcontainers는 테스트 실행 시 Docker를 이용해 PostgreSQL 데이터베이스 컨테이너를 동적으로 띄워준다.

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;

@Testcontainers
@SpringBootTest
class UserServiceIntegrationTest {

    // Testcontainers가 PostgreSQL 도커 컨테이너를 실행한다.
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine");

    // 실행된 컨테이너의 동적 주소와 자격 증명을 스프링 부트 설정에 주입한다.
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private UserService sut; // 테스트 대상 시스템

    @Autowired
    private UserRepository userRepository; // 데이터 검증을 위한 리포지터리

    @Autowired
    private CompanyRepository companyRepository;

    @MockBean // 비관리 의존성은 MockBean으로 대체한다.
    private MessageBus messageBus;

    @Test
    void changeEmail_should_change_user_and_company_data() {
        // --- 1. 준비 (Arrange) ---
        // 테스트에 필요한 초기 데이터를 실제 DB에 저장한다.
        Company company = companyRepository.save(new Company("mycorp.com", 10));
        User user = userRepository.save(new User("test@mycorp.com", company.getId()));
        String newEmail = "new@mycorp.com";

        // --- 2. 실행 (Act) ---
        sut.changeEmail(user.getId(), newEmail);

        // --- 3. 검증 (Assert) ---
        // DB에서 데이터를 다시 조회하여 상태가 올바르게 변경되었는지 확인한다.
        User updatedUser = userRepository.findById(user.getId());
        assertThat(updatedUser.getEmail()).isEqualTo(newEmail);

        Company updatedCompany = companyRepository.findById(company.getId());
        assertThat(updatedCompany.getNumberOfEmployees()).isEqualTo(11);

        // 목으로 처리된 의존성과의 상호작용을 검증한다.
        verify(messageBus).send("Email changed");
    }
}
```

이 테스트 코드는 통합 테스트의 전형적인 구조를 보여준다.

1. **테스트 환경 설정**: `@Testcontainers`와 `@DynamicPropertySource`를 사용하여 실제 PostgreSQL 데이터베이스를 테스트 환경에 연동한다. 비관리 의존성인 `MessageBus`는 `@MockBean`을 사용하여 스프링 컨텍스트 내에서 목 객체로 대체한다.
2. **준비(Arrange)**: 테스트에 필요한 초기 데이터를 `@Autowired`로 주입받은 실제 리포지터리를 사용하여 데이터베이스에 저장한다.
3. **실행(Act)**: 테스트 대상인 `sut.changeEmail()` 메서드를 호출한다.
4. **검증(Assert)**: 테스트 실행 후, 다시 리포지터리를 통해 데이터베이스에서 데이터를 조회하여 그 상태가 기대하는 대로 변경되었는지 직접 확인한다. 또한, 목으로 처리된 `MessageBus`와의 상호작용도 `verify`를 통해 검증한다.

이 하나의 테스트를 통해 우리는 `UserService`, `User`, `Company` 도메인 모델, JPA 리포지터리, 데이터베이스 스키마, 그리고 메시지 버스와의 연동 지점까지 모두가 올바르게 협력하여 동작함을 높은 신뢰도로 검증할 수 있다.

## 8.4 의존성 추상화를 위한 인터페이스 사용

우리가 테스트에서 목(Mock) 객체를 사용하고, 실제 운영 코드에서는 진짜 객체를 사용할 수 있는 이유는 바로 **인터페이스(Interface)** 덕분이다. 인터페이스는 객체지향 설계에서 의존성을 관리하고 결합도를 낮추는 가장 기본적인 도구이다. 통합 테스트의 맥락에서 인터페이스를 언제, 어떻게 사용해야 하는지 올바르게 이해하는 것은 테스트 가능한 코드를 설계하는 데 매우 중요하다.

### 8.4.1 인터페이스와 느슨한 결합

인터페이스는 특정 객체가 '무엇을 할 수 있는지(what)'를 정의하는 계약서와 같다. 이 계약서는 메서드의 이름, 매개변수, 반환 타입만을 명시할 뿐, 그 메서드가 '어떻게 동작하는지(how)'에 대한 구체적인 구현 내용은 포함하지 않는다.

어떤 클래스가 다른 구체 클래스(Concrete Class)에 직접 의존하는 대신, 인터페이스에 의존하게 되면 둘 사이의 결합은 느슨해진다. 클라이언트 코드는 오직 인터페이스라는 계약서에만 신경 쓰면 되므로, 그 뒤에 있는 실제 구현체가 어떤 것으로 교체되더라도 영향을 받지 않는다. 이는 마치 우리가 컴퓨터의 USB 포트(인터페이스)에 키보드, 마우스, 외장하드 등 어떤 장치(구현체)를 연결하더라도 컴퓨터가 동일한 방식으로 인식하는 것과 같다.

이렇게 느슨하게 결합된 코드는 변경에 유연하게 대처할 수 있고, 확장성이 뛰어나며, 무엇보다도 **테스트하기 쉽다.** 우리는 실제 운영 환경에서는 진짜 구현체를 주입하고, 테스트 환경에서는 가짜 구현체(테스트 대역)를 주입함으로써 동일한 클라이언트 코드를 다른 환경에서 다르게 동작하도록 만들 수 있다.

### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

**결론부터 말하자면, 프로세스 외부 의존성과 통신하는 모든 경계 지점에서는 항상 인터페이스를 사용해야 한다.** 이는 육각형 아키텍처의 포트(Port)에 해당하는 부분이다. 이유는 두 가지다.

첫째, **테스트 용이성** 때문이다. 이것이 가장 중요한 이유다. 5장에서 강조했듯이, 단위 테스트에서는 외부 시스템과의 통신을 테스트 대역으로 대체하여 테스트의 속도와 안정성을 확보해야 한다. 인터페이스가 없다면, 서비스 클래스가 구체적인 리포지터리 클래스에 직접 의존하게 되어 테스트 중에 이를 가짜 객체로 교체하는 것이 매우 까다로워진다. 인터페이스를 사용하면, 운영 코드에서는 `@Repository` 어노테이션이 붙은 실제 JPA 구현체를 주입하고, 단위 테스트에서는 `mock(UserRepository.class)`와 같이 간단하게 목 객체를 주입할 수 있다.

둘째, **아키텍처 유연성** 때문이다. 인터페이스를 통해 외부 의존성을 추상화하면, 나중에 기술 스택을 변경하기가 매우 쉬워진다. 예를 들어, `UserRepository`라는 인터페이스를 사용하고 있었다면, 현재의 JPA 기반 구현체(`JpaUserRepository`)를 나중에 MyBatis 기반의 구현체(`MybatisUserRepository`)나 심지어 다른 NoSQL 데이터베이스를 사용하는 구현체로 교체하더라도, `UserService`와 같은 상위 계층의 코드는 단 한 줄도 수정할 필요가 없다. 이는 특정 기술에 대한 종속성을 줄이고 애플리케이션의 장기적인 유지보수성을 크게 향상시킨다.

### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용

그렇다면 프로세스 내부의 클래스들, 즉 육각형 내부의 클래스들 사이에서도 항상 인터페이스를 사용해야 할까? 예를 들어, `UserService`를 위해 `IUserService`라는 인터페이스를 만들고, `PriceCalculator`를 위해 `IPriceCalculator`라는 인터페이스를 만드는 것이 좋을까?

**일반적으로는 그럴 필요가 없으며, 오히려 불필요한 복잡성을 추가하는 안티 패턴이 될 수 있다.**

그 이유는 다음과 같다. 7장에서 배웠듯이, 프로세스 내부의 협력 객체들은 단위 테스트 시 목으로 처리하는 대상이 아니라, 실제 객체를 함께 사용하여 테스트하는 것이 바람직하다. 따라서 테스트를 위해 구현체를 교체할 필요가 없으므로, 인터페이스를 만들 주된 동기가 사라진다.

인터페이스를 만드는 것은 오직 **해당 역할에 대해 여러 개의 다른 구현체가 존재하고, 이들을 바꿔가며 사용해야 할 실제 비즈니스 요구사항이 있을 때**만 정당화된다. 예를 들어, 할인 정책을 담당하는 `DiscountPolicy`라는 인터페이스가 있고, 상황에 따라 '정액 할인 정책(`FixAmountDiscountPolicy`)'과 '정률 할인 정책(`PercentDiscountPolicy`)'이라는 두 가지 구현체를 번갈아 적용해야 한다면 인터페이스를 사용하는 것이 훌륭한 설계이다.

하지만 단 하나의 구현체만 존재하는데도 불구하고 단지 '좋은 설계'라는 막연한 생각으로 모든 클래스에 인터페이스를 만드는 것은 YAGNI(You Aren't Gonna Need It, 필요 없을 거다) 원칙을 위반하는 것이다. 이는 코드의 양만 늘리고, 인터페이스와 구현체를 오가는 탐색 비용을 증가시켜 가독성을 해칠 뿐이다.

## 8.5 통합 테스트 모범 사례

효과적인 통합 테스트를 작성하기 위해 염두에 두어야 할 몇 가지 모범 사례가 있다. 이 사례들은 코드의 설계를 개선하고, 테스트의 신뢰도를 높이며, 유지보수 비용을 줄이는 데 도움이 된다.

### 8.5.1 도메인 모델 경계 명시하기

좋은 설계의 핵심은 도메인 모델을 외부 세계의 기술적인 관심사로부터 깨끗하게 유지하는 것이다. 즉, `User`나 `Company`와 같은 순수한 도메인 객체는 자신이 어떻게 데이터베이스에 저장되는지에 대해 전혀 알지 못해야 한다. JPA를 사용한다고 해서 `@Entity`나 `@Table` 같은 어노테이션이 도메인 모델 클래스에 포함되어서는 안 된다는 의미는 아니지만, 도메인 모델이 데이터베이스의 영속성(persistence) 로직에 대해 직접적인 책임을 가져서는 안 된다는 의미이다.

예를 들어, 도메인 객체 내부에 데이터베이스 트랜잭션과 관련된 코드가 있거나, 특정 ORM 프레임워크에만 의존적인 로직이 포함되어서는 안 된다. 이러한 영속성 관련 로직은 모두 리포지터리 계층에 위임되어야 한다.

이렇게 도메인 모델의 경계를 명확히 하면, 도메인 모델 자체는 외부 의존성이 없는 순수한 단위 테스트의 대상이 될 수 있다. 그리고 통합 테스트는 이 깨끗한 도메인 모델과 리포지터리 계층이 올바르게 협력하여 데이터베이스에 정보를 저장하고 조회하는 '연결 지점'만을 명확하게 테스트할 수 있게 된다.

### 8.5.2 계층 수 줄이기

간혹 애플리케이션 아키텍처가 불필요하게 많은 계층으로 나뉘어 있는 경우가 있다. 예를 들어, 컨트롤러(Controller) -> 퍼사드(Facade) -> 서비스(Service) -> 매니저(Manager) -> 리포지터리(Repository)와 같이 여러 단계를 거치는 구조이다.

이렇게 계층이 너무 많으면 각각의 계층이 하는 역할이 모호해지고, 단순히 아래 계층으로 호출을 전달만 하는 의미 없는 보일러플레이트 코드가 늘어난다. 이는 전체적인 시스템의 복잡도를 높이고, 유지보수를 어렵게 만든다.

통합 테스트 관점에서도 이는 좋지 않다. 테스트해야 할 '연결 지점'만 불필요하게 늘어날 뿐이다. 대부분의 비즈니스 애플리케이션에서는 **컨트롤러 -> 서비스 -> 리포지터리**의 3계층 구조만으로도 충분히 역할을 분리하고 관심사를 관리할 수 있다. 아키텍처는 가능한 한 단순하게 유지하는 것이 테스트하기 쉽고 이해하기 쉬운 코드를 만드는 지름길이다.

### 8.5.3 순환 의존성 제거하기

순환 의존성(Circular Dependency)은 클래스 A가 클래스 B에 의존하고, 동시에 클래스 B가 다시 클래스 A에 의존하는 상황을 말한다. 이는 심각한 설계 문제이며, 스프링과 같은 DI(의존성 주입) 프레임워크를 사용할 때 애플리케이션 컨텍스트가 로드되지 않는 등 심각한 오류를 발생시킨다.

통합 테스트는 `@SpringBootTest`를 통해 전체 애플리케이션 컨텍스트를 로드하는 경우가 많으므로, 순환 의존성이 존재하면 통합 테스트 자체가 실패하게 된다. 순환 의존성이 발견되었다면, 이는 두 클래스의 책임이 제대로 분리되지 않았다는 명백한 신호이다. 이 문제를 해결하기 위해서는 두 클래스가 공통으로 의존하는 새로운 제3의 클래스를 도입하거나, 한 클래스의 책임을 다른 클래스로 옮겨 의존성의 방향이 한쪽으로만 흐르도록 리팩터링해야 한다.

### 8.5.4 테스트에서 다중 실행 구절 사용

단위 테스트에서는 하나의 테스트 메서드에 하나의 실행(Act) 구절만 두어야 한다고 강조했다. 이는 테스트의 목적을 명확하고 단일하게 유지하기 위함이다.

하지만 통합 테스트에서는 이 규칙을 실용적인 이유로 완화할 수 있다. 통합 테스트는 데이터베이스 I/O 등으로 인해 실행 속도가 매우 느리다. 만약 어떤 객체의 생명주기와 관련된 일련의 동작(예: 생성 -> 수정 -> 삭제)을 테스트하고 싶을 때, 각 동작마다 별도의 통합 테스트를 작성하면 테스트 스위트의 전체 실행 시간이 매우 길어질 수 있다. 각 테스트가 독립적으로 데이터베이스 상태를 설정하고 정리해야 하기 때문이다.

이런 경우, 하나의 테스트 메서드 안에서 여러 개의 실행 구절과 검증 구절을 순서대로 배치하여 하나의 완전한 '사용자 스토리'를 검증하는 것이 더 효율적일 수 있다.

```java
@Test
void userLifeCycleStory() {
    // 1. 실행: 사용자를 생성한다.
    User createdUser = userService.createUser("test");
    // 1. 검증: 사용자가 DB에 올바르게 저장되었는지 확인한다.
    assertThat(userRepository.findById(createdUser.getId())).isPresent();

    // 2. 실행: 사용자의 이메일을 변경한다.
    userService.changeEmail(createdUser.getId(), "new@email.com");
    // 2. 검증: 이메일이 DB에 올바르게 업데이트되었는지 확인한다.
    assertThat(userRepository.findById(createdUser.getId()).get().getEmail()).isEqualTo("new@email.com");

    // 3. 실행: 사용자를 삭제한다.
    userService.deleteUser(createdUser.getId());
    // 3. 검증: 사용자가 DB에서 사라졌는지 확인한다.
    assertThat(userRepository.findById(createdUser.getId())).isEmpty();
}
```
이러한 접근법은 통합 테스트의 실행 시간을 줄여주는 실용적인 타협안이 될 수 있다. 다만, 이 방법을 사용할 때는 테스트 이름(`userLifeCycleStory`)에 전체 시나리오가 드러나도록 하고, 테스트 내부의 각 단계를 주석 등으로 명확히 구분하여 가독성을 해치지 않도록 주의해야 한다.

## 8.6 로깅 기능을 테스트하는 방법

로깅(Logging)은 모든 운영 환경 애플리케이션의 필수적인 부분이다. 로그는 시스템의 동작을 추적하고, 문제가 발생했을 때 원인을 파악하는 중요한 단서를 제공한다. 하지만 로깅 기능 자체를 테스트해야 하는지, 그리고 어떻게 테스트해야 하는지에 대해서는 많은 개발자가 혼란을 겪는다. 로깅은 명백한 부수 효과(side effect)이지만, 그 중요도나 검증 방식은 다른 외부 의존성과는 다소 다른 측면이 있다.

### 8.6.1 로깅을 테스트해야 하는가?

결론부터 말하자면, **대부분의 로깅 호출은 단위 테스트나 통합 테스트의 검증 대상이 되어서는 안 된다.**

그 이유는 로깅이 애플리케이션의 핵심 비즈니스 동작이 아니기 때문이다. `log.info("사용자 이메일 변경 시작")`과 같은 로그 메시지는 개발자나 운영자를 위한 정보일 뿐, 시스템의 최종 사용자나 다른 시스템에게는 아무런 영향을 미치지 않는 '식별할 수 없는 동작'이다. 이러한 로그 호출을 `verify` 구문을 통해 검증하기 시작하면, 테스트는 로그 메시지의 내용이나 형식 같은 구현 세부 사항에 쉽게 결합된다. 만약 로그 메시지의 문구를 조금 바꾸거나 로그 레벨을 `INFO`에서 `DEBUG`로 변경하는 간단한 수정만으로도 테스트가 실패하게 된다면, 이는 리팩터링 내성을 심각하게 해치는 전형적인 깨지기 쉬운 테스트가 된다.

다만, 여기에는 한 가지 예외가 있다. 로깅 자체가 시스템의 **핵심 비지니스 요구사항**인 경우이다. 예를 들어, 금융 거래 시스템에서 모든 거래 기록을 법적 요건에 따라 특정 형식의 감사 로그(Audit Log)로 반드시 남겨야 한다면, 이 감사 로그를 생성하는 것은 더 이상 단순한 정보 제공이 아니라 시스템의 중요한 책임 중 하나가 된다. 이 경우, 감사 로그가 올바르게 생성되었는지를 검증하는 것은 타당하며, 이는 일반적인 로깅 테스트라기보다는 '감사 기능 테스트'에 가깝다. 이러한 중요한 로그는 일반 로그와 분리된 별도의 목적지(예: 특정 파일, 데이터베이스 테이블)로 보내고, 그 결과를 검증하는 방식으로 테스트해야 한다.

### 8.6.2 로깅을 어떻게 테스트해야 하는가?

그럼에도 불구하고 로깅 기능 자체, 즉 "우리 시스템이 로거(Logger)를 통해 로그를 올바르게 '전달'하는가?"를 검증하고 싶을 때가 있다. 특히 앞서 말한 감사 로그처럼 중요한 로그를 다룰 때 그렇다. 이 경우, 우리는 로거를 외부 의존성으로 취급하고 테스트 대역을 사용하여 테스트할 수 있다.

이때의 목표는 로그 메시지의 정확한 내용보다는, 올바른 로그 레벨과 함께 메시지가 로거에 전달되었는지를 확인하는 것이다. 이를 위해 로거 인터페이스의 테스트 대역(목 또는 스파이)을 만들어 사용하고, 그 대역에 메시지가 전달되었는지 확인하는 방식을 사용할 수 있다.

많은 로깅 프레임워크(SLF4J, Logback 등)는 테스트 중에 로그 출력을 가로채고 검증할 수 있는 자체적인 테스트 라이브러리나 확장 기능을 제공하기도 한다. 이러한 도구를 사용하면 실제 콘솔이나 파일에 로그를 남기지 않고도 메모리 내에서 로그 이벤트를 검증할 수 있다.

하지만 다시 한번 강조하지만, 이러한 테스트는 로깅이 비즈니스적으로 매우 중요한 극히 일부의 경우에만 적용해야 한다. 일반적인 정보성 로그를 검증하는 데 이러한 노력을 들이는 것은 대부분의 경우 비용 대비 효과가 매우 낮다.

### 8.6.3 로깅이 얼마나 많으면 충분한가

"어디에 얼마나 많은 로그를 남겨야 하는가?"는 정답이 없는 질문이다. 하지만 좋은 가이드라인은 **육각형 아키텍처의 경계**에서 로그를 남기는 것이다.

* **외부 요청이 시스템에 들어올 때**: 컨트롤러 계층에서 HTTP 요청을 받았을 때, 요청의 주요 파라미터와 함께 로그를 남긴다. `log.info("사용자 생성 요청 수신: {}", userCreateRequest)`
* **시스템이 외부로 요청을 보낼 때**: 외부 API를 호출하거나 메시지 큐에 메시지를 보내기 직전에, 어떤 요청을 보내는지 로그를 남긴다. `log.info("결제 게이트웨이 호출: orderId={}, amount={}", order.getId(), order.getAmount())`
* **중요한 상태 변화가 발생했을 때**: 도메인 로직 내에서 비즈니스적으로 매우 중요한 상태 변화가 일어났을 때 로그를 남길 수 있다. 하지만 이 경우 로그 코드가 도메인 로직을 오염시키지 않도록 도메인 이벤트를 사용하는 것이 더 나은 접근법일 수 있다.

이처럼 시스템의 주요 입출력 지점에서 로그를 남기는 것만으로도, 대부분의 경우 시스템의 흐름을 추적하고 문제를 진단하는 데 충분한 정보를 얻을 수 있다. 모든 메서드의 시작과 끝에 로그를 남기는 것과 같은 과도한 로깅은 오히려 중요한 정보를 찾기 어렵게 만드는 소음(noise)이 될 뿐이다.

### 8.6.4 로거 인스턴스를 어떻게 전달하는가?

로거(Logger) 인스턴스를 사용하는 클래스에 어떻게 전달해야 할까? 가장 흔한 방법은 각 클래스마다 `private static final Logger log = LoggerFactory.getLogger(MyClass.class);` 와 같이 정적(static) 필드로 로거를 생성하는 것이다. 이 방법은 코드가 간결하고 편리하다는 장점이 있다.

하지만 이 방식은 의존성 주입(DI) 원칙에 위배되며, 로거를 테스트 대역으로 교체하는 것을 어렵게 만든다. 따라서 로깅 기능에 대한 테스트가 필요한 경우라면, 로거 역시 다른 의존성과 마찬가지로 **생성자 주입**을 통해 전달하는 것이 더 나은 방법이다.

```java
@Service
public class MyService {
    private final Logger log;
    private final OtherDependency otherDependency;

    public MyService(Logger log, OtherDependency otherDependency) {
        this.log = log;
        this.otherDependency = otherDependency;
    }
    // ...
}
```

이렇게 하면 테스트 시에 실제 로거 대신 목 로거를 쉽게 주입하여 동작을 검증할 수 있다. 물론, 앞서 말했듯이 대부분의 클래스에서는 로깅 테스트가 불필요하므로, 편리한 정적 필드 방식을 사용하는 것이 실용적인 선택일 수 있다. DI를 통한 로거 주입은 로깅 자체가 중요한 테스트 대상이 되는 클래스에만 선별적으로 적용하는 것이 좋다.

## 8.7 결론

이번 장에서는 단위 테스트만으로는 검증할 수 없는 영역, 즉 우리 코드와 외부 시스템 간의 연동을 검증하는 통합 테스트의 중요성과 역할에 대해 배웠다.

통합 테스트는 단위 테스트의 '격리'라는 한계를 극복하고, 데이터베이스, 외부 API 등과의 연동 과정에서 발생할 수 있는 중요한 버그들을 개발 초기에 발견하게 해주는 필수적인 안전망이다.

우리는 통합 테스트의 범위를 결정하기 위해 외부 의존성을 **관리 의존성**과 **비관리 의존성**으로 나누었다. 데이터베이스와 같이 우리가 직접 제어할 수 있는 관리 의존성은 통합 테스트의 핵심 대상으로, 반드시 실제 시스템과 연동하여 테스트해야 한다. 반면, 제3자 API와 같이 제어할 수 없는 비관리 의존성은 단위 테스트에서와 마찬가지로 테스트 대역으로 대체해야 한다.

실제 예제를 통해 Testcontainers와 같은 도구를 활용하여 실제 데이터베이스를 연동한 효과적인 통합 테스트를 작성하는 방법을 살펴보았다. 또한, 인터페이스를 올바르게 사용하여 테스트 가능한 코드를 설계하는 원칙과, 도메인 모델의 경계를 명확히 하고 아키텍처를 단순하게 유지하는 등의 모범 사례에 대해서도 논의했다.

마지막으로, 대부분의 경우 테스트 대상이 아니지만 때로는 중요한 비즈니스 요구사항이 될 수 있는 로깅 기능을 어떻게 다루고 테스트해야 하는지에 대한 가이드라인을 제시했다.

다음 장에서는 통합 테스트, 특히 목(Mock) 객체를 사용하는 테스트에서 흔히 발생하는 문제점들을 피하고 목의 가치를 극대화할 수 있는 구체적인 모범 사례들을 더 깊이 있게 탐구할 것이다.
