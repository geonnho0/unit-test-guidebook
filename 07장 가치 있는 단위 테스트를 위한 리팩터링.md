지금까지 우리는 좋은 단위 테스트의 이론적 기반을 탄탄히 다졌다. 좋은 테스트가 갖춰야 할 네 가지 요소, 목(Mock)의 올바른 사용법, 그리고 출력 기반 테스트를 가능하게 하는 함수형 아키텍처까지, 가치 있는 테스트를 작성하기 위한 핵심 원칙들을 모두 배웠다.

하지만 현실의 코드베이스는 언제나 이상적이지 않다. 우리는 종종 의존성이 복잡하게 얽혀있고, 비즈니스 로직과 부수 효과가 뒤섞여 있어 테스트하기 매우 어려운 레거시 코드나 신규 코드를 마주하게 된다. 이론을 아는 것과 이를 실제 문제에 적용하는 것은 전혀 다른 차원의 이야기다.

이 장에서는 바로 이 간극을 메우는 것을 목표로 한다. 우리는 배운 원칙들을 실제 무기로 사용하여, 테스트하기 어려운 코드를 테스트하기 쉬운 구조로 점진적으로 개선하는 **리팩터링** 과정을 실습할 것이다. 먼저 어떤 코드에 우리의 노력을 집중해야 가장 효과적인지 식별하는 방법을 배우고, 실제 고객 관리 시스템 예제를 통해 암시적 의존성을 제거하고, 복잡도를 분리하며, 최종적으로 가치 있는 단위 테스트를 작성하는 구체적인 단계를 밟아 나갈 것이다. 이 장을 마치고 나면, 독자들은 어떤 코드라도 자신감을 갖고 테스트 가능한 구조로 만들어 나갈 수 있는 실용적인 기술을 얻게 될 것이다.

## 7.1 리팩터링할 코드 식별하기

모든 코드가 동일한 가치를 가지지 않듯이, 모든 코드에 동일한 수준의 테스트와 리팩터링 노력을 쏟는 것은 비효율적이다. 한정된 시간과 자원을 가장 효과적으로 사용하기 위해서는, 어디에 집중해야 할지 현명하게 선택해야 한다. 리팩터링과 테스트의 가치를 극대화할 수 있는 코드, 즉 복잡하고 중요한 비즈니스 로직을 먼저 식별하는 것이 첫걸음이다.

### 7.1.1 코드의 네 가지 유형

코드베이스의 모든 코드는 두 가지 차원, 즉 **비즈니스 로직의 복잡도**와 **협력 객체의 수**를 기준으로 네 가지 유형으로 분류할 수 있다. 협력 객체의 수는 해당 코드가 얼마나 많은 의존성을 가지고 있는지를 나타낸다. 이 분류 모델은 우리가 어디에 테스트 노력을 집중해야 하는지 명확한 지도를 제공한다.

* **1사분면: 높은 복잡도 & 많은 협력 객체 (도메인 모델의 핵심)**
  이 영역의 코드는 복잡한 비즈니스 규칙을 포함하고 있으며, 동시에 다른 여러 클래스와 협력하여 동작한다. 애플리케이션의 가장 핵심적인 도메인 로직이 여기에 해당한다. 이 코드는 비즈니스적으로 매우 중요하고 버그가 발생했을 때 파급 효과가 크지만, 많은 의존성 때문에 테스트하기가 가장 어렵다. 이 영역이 바로 우리의 **주요 리팩터링 대상**이다. 우리의 목표는 리팩터링을 통해 이 영역의 코드를 3사분면으로 옮기는 것이다.

* **2사분면: 낮은 복잡도 & 많은 협력 객체 (컨트롤러, 오케스트레이터)**
  이 영역의 코드는 자체적인 비즈니스 로직은 거의 없지만, 여러 다른 서비스나 객체들을 호출하여 작업의 흐름을 조율하는 역할을 한다. 스프링 MVC의 컨트롤러나, 여러 리포지터리와 서비스를 단순히 엮어주는 간단한 서비스 클래스가 대표적인 예이다. 이 코드는 로직이 단순하므로 단위 테스트의 필요성이 상대적으로 낮으며, 주로 통합 테스트를 통해 검증하는 것이 더 효과적이다.

* **3사분면: 높은 복잡도 & 적은 협력 객체 (알고리즘, 유틸리티)**
  이 영역의 코드는 복잡한 계산이나 알고리즘을 수행하지만, 외부 의존성은 거의 없거나 아예 없다. 복잡한 유효성 검사기, 특정 포맷의 파서, 암호화 모듈 등이 여기에 해당한다. 이 코드는 **단위 테스트의 이상적인 대상**이다. 입력과 출력의 관계가 명확하므로 출력 기반 테스트를 작성하기 매우 쉬우며, 버그 발생 가능성이 높아 철저한 테스트가 반드시 필요하다.

* **4.사분면: 낮은 복잡도 & 적은 협력 객체 (간단한 도우미 클래스, DTO)**
  이 영역의 코드는 로직도 단순하고 의존성도 거의 없다. 간단한 헬퍼 메서드, 값을 담는 역할만 하는 DTO(Data Transfer Object) 등이 여기에 해당한다. 이 코드는 너무 단순해서 버그가 거의 발생하지 않으므로, 테스트를 작성하는 데 시간을 투자할 가치가 거의 없다.

이 사분면 모델에 따르면, 우리의 테스트 및 리팩터링 전략은 명확해진다. 먼저 **1사분면**의 복잡하고 의존성 높은 코드를 식별한다. 그리고 리팩터링을 통해 이 코드에서 순수한 비즈니스 로직을 추출하여 의존성이 거의 없는 **3사분면**으로 옮긴다. 이렇게 3사분면으로 옮겨진 코드는 가치 있는 단위 테스트를 작성하기에 완벽한 대상이 된다.

### 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

1사분면의 코드를 3사분면으로 옮기는 구체적인 리팩터링 기법 중 하나가 바로 **험블 객체(Humble Object) 패턴**이다. 이 패턴은 6장에서 살펴본 함수형 아키텍처의 '비즈니스 결정과 부수 효과의 분리' 원칙을 객체지향적으로 구현한 것이다.

험블 객체 패턴의 아이디어는 테스트하기 어려운 로직과 테스트하기 쉬운 로직을 하나의 클래스에서 분리하는 것이다.

1. 먼저, 기존 클래스에서 테스트하기 어려운 모든 로직(UI, 데이터베이스, 네트워크 통신 등 외부 의존성과 상호작용하는 부분)을 식별한다.
2. 이 로직들을 '험블(Humble, 비천한)' 객체로 옮긴다. 이 험블 객체는 최대한 멍청하게 만들어, 어떤 비즈니스 로직도 포함하지 않고 오직 외부 세계와의 통신을 전달하는 역할만 하도록 한다. 이 객체는 너무 단순해서 굳이 단위 테스트를 할 필요가 없다.
3. 기존 클래스에는 외부 의존성이 제거된, 순수한 비즈니스 로직만이 남게 된다. 이 클래스는 이제 외부 세계와 완전히 분리되어 테스트하기 매우 쉬운 상태가 된다.

이 과정을 통해 우리는 1사분면에 있던 복잡한 클래스를, 테스트할 필요가 거의 없는 단순한 험블 객체(2사분면 또는 4사분면)와 테스트하기 매우 쉬운 순수한 비즈니스 로직 클래스(3사분면) 두 개로 분할할 수 있다. 이어지는 절에서는 실제 예제를 통해 이 패턴을 적용하여 코드를 리팩터링하고 테스트하는 전 과정을 살펴볼 것이다.

## 7.2 가치 있는 단위 테스트를 위한 리팩터링하기

이론을 실제 코드로 옮겨보는 시간이다. 우리는 지금부터 전형적인 1사분면 코드, 즉 비즈니스 로직과 외부 의존성이 복잡하게 얽혀 있어 테스트하기 매우 어려운 코드를 단계별로 리팩터링할 것이다. 최종 목표는 이 코드에서 핵심 비즈니스 로직을 분리하여, 3사분면에 해당하는 견고하고 가치 있는 단위 테스트를 작성하는 것이다.

### 7.2.1 고객 관리 시스템 소개

우리가 리팩터링할 대상은 고객의 이메일을 변경하고, 회사의 정보를 업데이트하는 스프링 MVC 컨트롤러의 한 메서드이다.

**초기 코드: 테스트하기 어려운 컨트롤러**

```java
@RestController
public class UserController {
    private final UserRepository userRepository;
    private final DatabaseLogger databaseLogger;

    public UserController(UserRepository userRepository, DatabaseLogger databaseLogger) {
        this.userRepository = userRepository;
        this.databaseLogger = databaseLogger;
    }

    @PutMapping("/users/{userId}")
    public void changeEmail(
            @PathVariable int userId,
            @RequestParam String newEmail
    ) {
        // 1. 데이터베이스에서 사용자 정보를 가져온다. (외부 I/O)
        User user = userRepository.findById(userId);

        // 2. 외부 API를 통해 회사 정보를 가져온다. (암시적 의존성, 외부 I/O)
        Object[] companyData = CompanyRepository.getCompany();
        String companyDomainName = (String) companyData[0];
        int numberOfEmployees = (int) companyData[1];

        // 3. 복잡한 비즈니스 로직
        int newNumberOfEmployees = user.getEmail().equals(newEmail)
                ? numberOfEmployees
                : numberOfEmployees + 1;
        
        // 4. 회사 정보를 업데이트한다. (암시적 의존성, 외부 I/O)
        CompanyRepository.saveCompany(companyDomainName, newNumberOfEmployees);

        // 5. 사용자 이메일을 변경하고 저장한다. (외부 I/O)
        user.setEmail(newEmail);
        userRepository.save(user);

        // 6. 외부 메시지 버스에 메시지를 보낸다. (암시적 의존성, 외부 I/O)
        MessageBus messageBus = new MessageBus();
        messageBus.send("Email changed");

        // 7. 데이터베이스에 로그를 남긴다. (외부 I/O)
        databaseLogger.log("OK");
    }
}
```

이 `changeEmail` 메서드는 테스트하기 매우 어렵다. 그 이유는 명확하다.

* **외부 I/O 폭탄**: 실제 데이터베이스(`UserRepository`, `DatabaseLogger`), 외부 API(`CompanyRepository`), 메시지 버스(`MessageBus`) 등 수많은 외부 의존성과 직접 통신한다. 이 코드를 테스트하려면 전체 스프링 컨텍스트를 띄우고 실제 데이터베이스와 외부 서비스가 모두 필요하다.
* **암시적 의존성**: `CompanyRepository`의 정적(static) 메서드를 직접 호출하고, `MessageBus` 객체를 메서드 내부에서 `new` 키워드로 직접 생성하고 있다. 이러한 암시적 의존성은 테스트 중에 가짜 객체로 대체하는 것을 불가능하게 만든다.
* **책임의 혼합**: 외부 통신, 데이터 변환, 핵심 비즈니스 로직(새로운 직원 수를 계산하는 부분)이 모두 한 메서드 안에 뒤섞여 있다.

우리의 목표는 이 엉망진창인 코드에서 핵심 비즈니스 로직, 즉 '이메일이 변경되었을 때 새로운 직원 수를 어떻게 결정하는가' 하는 부분을 분리하여 빠르고 안정적인 단위 테스트로 보호하는 것이다.

### 7.2.2 1단계: 암시적 의존성을 명시적으로 만들기

리팩터링의 첫걸음은 숨어있는 의존성을 밖으로 꺼내 명시적으로 만드는 것이다. 이는 의존성 주입(Dependency Injection) 원칙을 적용하여 달성할 수 있다. 테스트 중에 이 의존성들을 테스트 대역(목, 스텁 등)으로 대체하려면, 반드시 외부에서 주입할 수 있는 형태여야 한다.

현재 코드의 암시적 의존성은 `CompanyRepository`와 `MessageBus`이다. 이들을 컨트롤러의 필드로 옮기고 생성자를 통해 주입받도록 수정하자.

**리팩터링 후: 명시적 의존성**

```java
@RestController
public class UserController {
    private final UserRepository userRepository;
    private final DatabaseLogger databaseLogger;
    // 암시적 의존성을 명시적으로 변경
    private final CompanyRepository companyRepository;
    private final MessageBus messageBus;

    public UserController(
            UserRepository userRepository,
            DatabaseLogger databaseLogger,
            CompanyRepository companyRepository, // 생성자를 통해 주입
            MessageBus messageBus // 생성자를 통해 주입
    ) {
        this.userRepository = userRepository;
        this.databaseLogger = databaseLogger;
        this.companyRepository = companyRepository;
        this.messageBus = messageBus;
    }

    @PutMapping("/users/{userId}")
    public void changeEmail(
            @PathVariable int userId,
            @RequestParam String newEmail
    ) {
        User user = userRepository.findById(userId);

        // 정적 호출 대신 주입된 인스턴스 사용
        Object[] companyData = companyRepository.getCompany();
        String companyDomainName = (String) companyData[0];
        int numberOfEmployees = (int) companyData[1];

        int newNumberOfEmployees = user.getEmail().equals(newEmail)
                ? numberOfEmployees
                : numberOfEmployees + 1;

        // 정적 호출 대신 주입된 인스턴스 사용
        companyRepository.saveCompany(companyDomainName, newNumberOfEmployees);

        user.setEmail(newEmail);
        userRepository.save(user);

        // new로 생성하는 대신 주입된 인스턴스 사용
        messageBus.send("Email changed");

        databaseLogger.log("OK");
    }
}
```

이 간단한 변경만으로도 우리는 큰 진전을 이루었다. 이제 이 컨트롤러를 테스트할 때 `CompanyRepository`와 `MessageBus`의 목 객체를 주입하여 외부 API나 메시지 버스와의 실제 통신 없이도 테스트를 수행할 수 있게 되었다.

하지만 아직 갈 길이 멀다. 이 코드는 여전히 테스트하기 어렵다. 비록 모든 의존성을 목으로 처리할 수는 있게 되었지만, 여전히 수많은 목 객체를 설정하고 검증해야 하는 복잡하고 취약한 테스트를 작성해야만 한다. 핵심 비즈니스 로직은 여전히 외부 통신 코드와 뒤엉켜 있다. 다음 단계에서는 이들을 분리하는 작업을 시작할 것이다.

### 7.2.3 2단계: 애플리케이션 서비스 계층 도입

컨트롤러는 HTTP 요청을 받아 응답을 보내는 역할에만 집중해야 한다. 현재 `UserController`는 이메일 변경과 관련된 모든 비즈니스 로직과 데이터 처리 로직까지 떠안고 있어 책임이 너무 많다. 이는 SRP(단일 책임 원칙) 위반이다.

이 문제를 해결하기 위해 **애플리케이션 서비스(Application Service)** 계층을 도입한다. 서비스 계층은 컨트롤러로부터 요청을 받아 필요한 비즈니스 로직을 오케스트레이션하고, 그 결과를 다시 컨트롤러에 반환하는 역할을 전담한다.

`changeEmail` 메서드의 모든 로직을 새로운 `UserService` 클래스로 옮기자. 컨트롤러는 이제 이 `UserService`에 작업을 위임하는 역할만 수행하므로 매우 단순해진다.

**새로운 UserService 클래스**

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final CompanyRepository companyRepository;
    private final MessageBus messageBus;

    // DatabaseLogger는 이 서비스와 직접 관련이 없으므로 일단 제외

    public UserService(
            UserRepository userRepository,
            CompanyRepository companyRepository,
            MessageBus messageBus
    ) {
        this.userRepository = userRepository;
        this.companyRepository = companyRepository;
        this.messageBus = messageBus;
    }

    public void changeEmail(int userId, String newEmail) {
        User user = userRepository.findById(userId);

        Object[] companyData = companyRepository.getCompany();
        String companyDomainName = (String) companyData[0];
        int numberOfEmployees = (int) companyData[1];

        int newNumberOfEmployees = user.getEmail().equals(newEmail)
                ? numberOfEmployees
                : numberOfEmployees + 1;

        companyRepository.saveCompany(companyDomainName, newNumberOfEmployees);

        user.setEmail(newEmail);
        userRepository.save(user);

        messageBus.send("Email changed");
    }
}
```

**단순해진 UserController**

```java
@RestController
public class UserController {
    private final UserService userService;
    private final DatabaseLogger databaseLogger;

    public UserController(UserService userService, DatabaseLogger databaseLogger) {
        this.userService = userService;
        this.databaseLogger = databaseLogger;
    }

    @PutMapping("/users/{userId}")
    public void changeEmail(
            @PathVariable int userId,
            @RequestParam String newEmail
    ) {
        // 모든 로직을 서비스 계층에 위임
        userService.changeEmail(userId, newEmail);
        
        // 컨트롤러의 고유 책임인 로깅은 남겨둠
        databaseLogger.log("OK");
    }
}
```

이 리팩터링을 통해 우리는 **관심사의 분리(Separation of Concerns)**를 달성했다. 컨트롤러는 이제 HTTP 처리라는 자신의 역할에만 충실하고, 이메일 변경과 관련된 모든 복잡한 로직은 `UserService`가 담당하게 되었다.

우리가 테스트하고 싶은 핵심 비즈니스 로직은 이제 `UserService` 안에 있다. 비록 `UserService`가 여전히 테스트하기 어려운 1사분면의 코드이긴 하지만, 로직이 한 곳에 모였으므로 다음 단계의 리팩터링을 수행하기 훨씬 더 좋은 위치에 서게 되었다.

### 7.2.4 3단계: 애플리케이션 서비스 복잡도 낮추기

이제 우리의 목표는 `UserService` 내부에서 순수한 비즈니스 로직을 추출하는 것이다. 현재 `UserService`는 여전히 외부 통신과 비즈니스 로직이 뒤섞여 있다. 이들을 분리하기 위해, 우리는 6장에서 배운 함수형 아키텍처의 아이디어를 적용할 것이다. 즉, **비즈니스 결정**과 **부수 효과**를 분리하는 것이다.

먼저, `UserService.changeEmail` 메서드에서 비즈니스 로직에 필요한 모든 입력 데이터를 가져오는 부분과, 그 데이터를 바탕으로 실제 외부 시스템에 쓰는 부분을 명확히 구분하자.

1.  **읽기(Read)**: `userRepository.findById(userId)` 와 `companyRepository.getCompany()` 호출을 통해 비즈니스 로직에 필요한 모든 데이터를 메모리로 가져온다.
2.  **계산(Calculate)**: 읽어온 데이터를 사용하여 순수한 비즈니스 결정을 내린다. 즉, 새로운 직원 수를 계산한다.
3.  **쓰기(Write)**: 계산된 결과를 바탕으로 외부 시스템(데이터베이스, 메시지 버스)에 데이터를 쓴다.

이 흐름에 따라 `UserService`를 리팩터링하면 다음과 같다.

**리팩터링된 UserService**

```java
@Service
public class UserService {
    // ... 생성자 ...

    public void changeEmail(int userId, String newEmail) {
        // --- 1. 읽기(Read) ---
        User user = userRepository.findById(userId);
        Object[] companyData = companyRepository.getCompany();
        String companyDomainName = (String) companyData[0];
        int numberOfEmployees = (int) companyData[1];

        // --- 2. 계산(Calculate) ---
        // 이 부분이 바로 우리가 테스트하고 싶은 핵심 로직이다.
        int newNumberOfEmployees = user.getEmail().equals(newEmail)
                ? numberOfEmployees
                : numberOfEmployees + 1;
        
        // --- 3. 쓰기(Write) ---
        companyRepository.saveCompany(companyDomainName, newNumberOfEmployees);
        user.setEmail(newEmail);
        userRepository.save(user);
        messageBus.send("Email changed");
    }
}
```

이제 핵심 비즈니스 로직('계산' 부분)이 명확하게 드러났다. 다음 단계에서는 이 로직을 별도의 클래스로 완전히 분리하여 테스트 가능한 단위로 만들 것이다.

### 7.2.5 4단계: 새 Company와 User 클래스 소개

'계산' 부분의 로직은 사실 특정 사용자나 회사에 귀속된 비즈니스 규칙이다. 객체지향 설계의 기본 원칙 중 하나는 **데이터와 그 데이터를 사용하는 로직을 같은 곳에 두는 것**이다.

현재 `UserService`는 사용자(User)와 회사(Company)의 데이터를 가져와서, 그들의 속성인 것처럼 보이는 로직(직원 수 변경)을 대신 처리해주고 있다. 이는 응집도가 낮은 설계이다. 이 로직을 데이터가 있는 곳, 즉 `Company`와 `User` 도메인 클래스로 직접 옮기는 것이 훨씬 더 자연스럽고 객체지향적이다.

먼저, 회사 정보를 담을 `Company` 도메인 클래스를 만들고, 직원 수를 변경하는 로직을 이 클래스의 메서드로 옮기자.

**새로운 Company 도메인 클래스**

```java
public class Company {
    private String domainName;
    private int numberOfEmployees;

    // 생성자, getter ...

    public void changeNumberOfEmployees(int delta) {
        // 자신의 상태를 변경하는 로직
        this.numberOfEmployees += delta;
    }
}
```

이제 `User` 클래스도 수정하여, 이메일이 변경될 때 회사의 직원 수를 변경하라는 메시지를 `Company` 객체에 보내도록 만들자.

**수정된 User 도메인 클래스**

```java
public class User {
    private String email;
    // ...

    public void changeEmail(String newEmail, Company company) {
        if (this.email.equals(newEmail)) {
            // 이메일이 변경되지 않으면 아무 일도 하지 않음
            return;
        }

        // 회사 객체에 직원 수를 변경하라는 메시지를 보낸다.
        company.changeNumberOfEmployees(1);
        
        this.email = newEmail;
    }
}
```

이 리팩터링을 통해 우리는 `UserService`에 흩어져 있던 비즈니스 로직을 `User`와 `Company`라는 응집도 높은 도메인 객체 안으로 성공적으로 옮겼다.

이제 `UserService`는 이 도메인 객체들을 사용하여 작업을 오케스트레이션하는 역할만 수행하므로 훨씬 더 단순해진다.

**최종적으로 단순해진 UserService**

```java
@Service
public class UserService {
    // ... 생성자 ...

    public void changeEmail(int userId, String newEmail) {
        // 1. 읽기 (Read)
        User user = userRepository.findById(userId);
        Company company = companyRepository.getCompany(); // getCompany가 Company 객체를 반환한다고 가정

        // 2. 계산 (도메인 모델에 위임)
        user.changeEmail(newEmail, company);

        // 3. 쓰기 (Write)
        companyRepository.saveCompany(company);
        userRepository.save(user);

        // 메시지 버스 로직은 도메인 이벤트로 처리하는 것이 더 좋지만, 여기서는 일단 남겨둠
        messageBus.send("Email changed");
    }
}
```

드디어 우리의 핵심 비즈니스 로직이 외부 의존성이 전혀 없는 순수한 도메인 객체(`User`, `Company`) 안으로 캡슐화되었다. 이 도메인 객체들은 이제 3사분면에 위치하며, 가치 있는 단위 테스트를 작성하기에 완벽한 대상이 되었다.

## 7.3 최적의 단위 테스트 커버리지 분석

기나긴 리팩터링 여정이 끝났다. 우리는 테스트하기 불가능해 보였던 코드를 체계적으로 분해하여, 테스트 가능한 순수한 도메인 모델과, 이들을 조율하는 단순한 서비스 및 컨트롤러 계층으로 재구성했다. 이제 우리는 어떤 부분을 단위 테스트로 검증해야 가장 효율적인지, 즉 최소한의 노력으로 최대의 가치를 얻을 수 있는지 분석할 수 있는 위치에 섰다.

### 7.3.1 도메인 계층과 유틸리티 코드 테스트하기

우리가 리팩터링을 통해 최종적으로 도달한 목표는 바로 **도메인 계층(Domain Layer)**을 만드는 것이었다. 우리의 `User`와 `Company` 클래스가 바로 여기에 해당한다. 이 도메인 계층은 7.1.1절에서 설명한 코드 사분면 모델에서 **3사분면(높은 복잡도, 적은 협력 객체)**에 완벽하게 부합한다.

* **높은 복잡도**: '사용자 이메일이 변경될 때 회사의 직원 수를 증가시킨다'는 규칙은 우리 시스템의 핵심 비즈니스 로직이다. 지금은 간단해 보이지만, 앞으로 '특정 도메인의 이메일로는 변경 불가', '회사의 등급에 따라 직원 수 증가 정책 변경' 등 수많은 규칙이 추가될 수 있는 복잡성의 중심지이다.
* **적은 협력 객체**: `User.changeEmail` 메서드는 오직 `Company` 객체에만 의존하며, 이마저도 테스트 시 실제 `Company` 객체를 쉽게 만들어 전달할 수 있다. 외부 I/O나 프레임워크에 대한 의존성이 전혀 없다.

이러한 특성 때문에 도메인 계층은 단위 테스트의 '스위트 스팟(Sweet Spot)'이다. 이 부분에 대한 단위 테스트는 네 가지 핵심 요소를 모두 만족시킨다.

* **회귀 방지**: 가장 중요하고 복잡한 비즈니스 로직을 직접 검증하므로, 버그를 잡아낼 확률이 매우 높다.
* **리팩터링 내성**: 외부 의존성이 없으므로, 내부 구현이 바뀌어도 비즈니스 규칙만 유지된다면 테스트는 깨지지 않는다.
* **빠른 피드백**: 메모리 내에서만 실행되므로 속도가 매우 빠르다.
* **유지보수성**: 테스트의 의도가 명확하고 구조가 단순하다.

이제 `User` 클래스에 대한 가치 있는 단위 테스트를 작성해 보자.

```java
@Test
void changeEmail_should_increase_company_employees_when_email_is_changed() {
    // Arrange
    Company company = new Company("mycorp.com", 10);
    User sut = new User("test@mycorp.com");

    // Act
    sut.changeEmail("new@mycorp.com", company);

    // Assert
    // 상태 기반 테스트: Company 객체의 최종 상태를 검증한다.
    assertThat(company.getNumberOfEmployees()).isEqualTo(11);
}

@Test
void changeEmail_should_not_change_employees_when_email_is_not_changed() {
    // Arrange
    Company company = new Company("mycorp.com", 10);
    User sut = new User("test@mycorp.com");

    // Act
    sut.changeEmail("test@mycorp.com", company);

    // Assert
    assertThat(company.getNumberOfEmployees()).isEqualTo(10);
}
```

이 테스트들은 빠르고, 안정적이며, 가장 중요한 비즈니스 규칙을 명확하게 문서화하고 검증한다. 이것이 바로 우리가 리팩터링을 통해 얻고자 했던 최종 결과물이다. 코드베이스의 모든 유틸리티 코드나 알고리즘 역시 3사분면에 해당하므로, 이와 같은 방식으로 철저히 단위 테스트해야 한다.

### 7.3.2 나머지 세 사분면에 대한 코드 테스트하기

그렇다면 도메인 계층을 제외한 나머지 코드들은 어떻게 해야 할까?

* **컨트롤러 (2사분면: 낮은 복잡도, 많은 협력 객체)**: 리팩터링 후 `UserController`는 `UserService`를 호출하는 한 줄짜리 위임 로직만 남았다. 이처럼 로직이 거의 없는 코드를 위해 복잡한 목(Mock) 객체를 설정하며 단위 테스트를 작성하는 것은 비용 대비 효과가 매우 낮다. 컨트롤러는 실제 HTTP 요청부터 데이터베이스까지 이어지는 전체 흐름을 검증하는 **엔드 투 엔드(End-to-End) 테스트**나 **통합 테스트**의 대상이 되는 것이 훨씬 더 적합하다.

* **애플리케이션 서비스 (2사분면)**: 리팩터링 후 `UserService` 역시 도메인 객체들을 조율하는 오케스트레이션 역할만 한다. 데이터베이스에서 도메인 객체를 읽어오고(Read), 도메인 메서드를 호출하며(Calculate), 변경된 도메인 객체를 다시 저장하는(Write) 단순한 흐름을 가진다. 이 역시 단위 테스트보다는 실제 데이터베이스를 연동하는 통합 테스트로 검증하는 것이 더 의미 있다. 통합 테스트를 통해 우리는 도메인 모델과 데이터베이스 매핑(JPA 어노테이션 등)이 올바르게 동작하는지까지 확인할 수 있다.

* **간단한 코드 (4사분면: 낮은 복잡도, 적은 협력 객체)**: DTO나 간단한 헬퍼 클래스처럼 로직이 거의 없는 코드는 버그 발생 가능성이 희박하므로, 굳이 테스트를 작성하지 않아도 무방하다. 여기에 테스트를 작성하는 것은 코드 커버리지 숫자를 높이는 것 외에는 거의 가치가 없다.

결론적으로, 우리의 테스트 전략은 명확하다. **단위 테스트는 3사분면의 코드, 즉 복잡한 비즈니스 로직을 담고 있는 도메인 모델과 유틸리티 코드에 집중한다.** 그리고 나머지 부분, 특히 외부 의존성과의 통합 지점은 통합 테스트나 엔드 투 엔드 테스트를 통해 보완한다. 이 전략을 통해 우리는 테스트 스위트 전체의 가치를 극대화하고, 유지보수 비용을 최소화할 수 있다.

### 7.3.3 전제 조건을 테스트해야 하는가?

간혹 개발자들은 메서드의 전제 조건(precondition)을 확인하는 방어적인 코드에 대해서도 단위 테스트를 작성해야 하는지 고민한다. 예를 들어, null 입력을 방지하기 위한 코드다.

```java
public void someMethod(User user) {
    if (user == null) {
        throw new IllegalArgumentException("user는 null일 수 없습니다.");
    }
    // ... 실제 로직 ...
}
```

이러한 방어적 코드를 테스트하는 것은 일반적으로 가치가 낮다. `someMethod(null)`을 호출하여 `IllegalArgumentException`이 발생하는지 확인하는 테스트는 우리에게 비즈니스 로직에 대한 어떤 새로운 정보도 주지 않는다.

이런 방어적 코드는 테스트의 대상이라기보다는, 개발자의 실수를 방지하기 위한 안전장치로 이해해야 한다. 정적 분석 도구나 코드 리뷰를 통해 충분히 관리될 수 있으며, 굳이 단위 테스트를 추가하여 테스트 스위트를 불필요하게 늘릴 필요는 없다. 단위 테스트는 항상 애플리케이션의 핵심 비즈니스 로직을 검증하는 데 집중해야 한다.

## 7.4 컨트롤러에서 조건부 로직 처리

리팩터링을 통해 컨트롤러의 로직을 대부분 서비스 계층으로 옮겼지만, 때로는 컨트롤러에 조건부 로직이 남아있어야 하는 경우가 있다. 예를 들어, 사용자의 권한에 따라 다른 서비스 메서드를 호출하거나, 특정 조건에서는 아예 작업을 수행하지 않고 다른 응답을 반환해야 할 때다. 이러한 로직을 어떻게 처리하는 것이 좋을까?

### 7.4.1 CanExecute / Execute 패턴 사용

한 가지 유용한 패턴은 **CanExecute / Execute 패턴**이다. 이 패턴은 작업을 실제로 수행하는 `Execute` 로직과, 그 작업을 수행할 수 있는지 여부를 미리 확인하는 `CanExecute` 로직을 분리하는 것이다.

컨트롤러는 먼저 `CanExecute` 로직을 호출하여 작업 수행 가능 여부를 확인한다. 만약 가능하다는 응답을 받으면, 그때 `Execute` 로직을 호출한다. 이 패턴을 적용하면 컨트롤러의 조건부 로직이 명확해지고, 각 서비스의 책임이 명확하게 분리된다.

```java
// 예시: 사용자 등급에 따라 다른 할인 정책 적용
if (discountService.canApplyVipDiscount(user)) {
    discountService.applyVipDiscount(order);
} else {
    discountService.applyStandardDiscount(order);
}
```

이 패턴은 컨트롤러의 의사결정 과정을 명확하게 보여주지만, 컨트롤러가 비즈니스 규칙(어떤 조건에서 VIP 할인을 적용할 수 있는지)을 일부 알게 된다는 단점이 있다.

### 7.4.2 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

더 발전된 방법은 **도메인 이벤트(Domain Event)**를 사용하는 것이다. 도메인 이벤트는 도메인 내에서 발생한 의미 있는 사건을 표현하는 객체다.

앞선 `UserService` 예제에서 `user.changeEmail()` 메서드가 실행될 때, `User` 객체는 단순히 상태를 바꾸는 것뿐만 아니라 `UserEmailChangedEvent`라는 이벤트 객체를 생성하여 내부에 기록해 둘 수 있다.

`UserService`는 `user.changeEmail()`을 호출한 뒤, `user` 객체에 쌓인 이벤트 목록을 가져와 이벤트 버스(또는 메시지 버스)에 발행(publish)하는 역할만 하면 된다. 그러면 이 이벤트를 구독(subscribe)하고 있는 다른 서비스들(예: `NotificationService`)이 이메일 발송과 같은 후속 조치를 알아서 처리하게 된다.

이 방식을 사용하면 `UserService`는 이메일 변경 후 어떤 추가 작업이 일어나야 하는지 전혀 알 필요가 없게 된다. 이는 시스템 간의 결합도를 극적으로 낮춰주는 매우 강력한 패턴이다. 컨트롤러 역시 마찬가지로, 오직 주된 작업만 서비스에 위임하고, 그로 인해 파생되는 부가적인 작업들은 도메인 이벤트를 통해 비동기적이고 독립적으로 처리되도록 만들 수 있다.

### 7.5 결론

이번 장에서 우리는 테스트하기 어려운 코드를 가치 있는 단위 테스트의 대상으로 바꾸는 실용적인 리팩터링 여정을 함께했다.

우리는 코드베이스를 네 가지 사분면으로 분석하여 우리의 노력을 어디에 집중해야 할지 배웠다. 목표는 복잡하고 의존성이 높은 1사분면의 코드를 식별하고, 리팩터링을 통해 순수한 비즈니스 로직을 3사분면으로 옮기는 것이었다.

실제 고객 관리 시스템 컨트롤러 예제를 통해, 암시적 의존성을 명시적으로 만들고, 애플리케이션 서비스 계층을 도입하며, 최종적으로 핵심 비즈니스 로직을 순수한 도메인 모델로 캡슐화하는 과정을 단계별로 수행했다. 이 과정을 통해 우리는 복잡하게 얽혀있던 코드로부터 빠르고 안정적이며 유지보수하기 쉬운 단위 테스트를 작성할 수 있는 순수한 도메인 객체를 얻어냈다.

최적의 테스트 전략은 단위 테스트를 도메인 계층과 같은 3사분면 코드에 집중하고, 컨트롤러나 서비스와 같은 다른 계층은 통합 테스트나 엔드 투 엔드 테스트로 보완하는 것이다.

이로써 우리는 가치 있는 단위 테스트를 작성하는 데 필요한 모든 이론과 실용적인 기술을 갖추게 되었다. 다음 3부에서는 단위 테스트만으로는 부족한 영역, 즉 외부 시스템과의 연동을 검증하는 통합 테스트의 세계로 나아갈 것이다.
